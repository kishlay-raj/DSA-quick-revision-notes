
**Dynamic programming** 

| Question                                                                                                                                                                                                                                                                                    | Hint to remember                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Coding hint                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | Misktake to avoid                                                                                                                          | Not solved | Revision needed |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ---------- | --------------- |
| [Climbing Stars](https://takeuforward.org/data-structure/dynamic-programming-climbing-stairs/)<br>Number of ways                                                                                                                                                                            | Use dynamic programming: define `dp[i]` as the sum of `dp[i-1]` and `dp[i-2]` with initial values `dp[0] = 1` and `dp[1] = 1`. Iterate from 2 to `n` to fill `dp` and return `dp[n]`.                                                                                                                                                                                                                                                                                                                                                                                                        | ![[Pasted image 20240707223443.png]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                            |            |                 |
| [Frog Jump(DP-3)](https://takeuforward.org/data-structure/dynamic-programming-frog-jump-dp-3/)<br>Weighted.<br>Minimum cost to reach stair                                                                                                                                                  | Use a dynamic programming array `dp` where `dp[i]` represents the minimum cost to reach stone `i`. For each stone `i`, update `dp[i]` by considering the costs from the previous stone `i-1` and the stone before that `i-2` using `dp[i] = min(dp[i-1] + cost(i-1, i), dp[i-2] + cost(i-2, i))`.                                                                                                                                                                                                                                                                                            | ![[Pasted image 20240707225136.png]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                            | ns         |                 |
| [Frog Jump with k distances(DP-4)](https://takeuforward.org/data-structure/dynamic-programming-frog-jump-with-k-distances-dp-4/)<br>Instead of 1 or 2, Now frog can jump at max 4 steps                                                                                                     | To solve the Frog Jump with k Distances problem, use a dynamic programming array `dp` where `dp[i]` represents the minimum cost to reach stone `i`. For each stone `i`, update `dp[i]` by considering the minimum cost to jump from any of the previous `k` stones, using `dp[i] = min(dp[j] + cost(j, i))` for all `j` from `i-1` to `i-k`.                                                                                                                                                                                                                                                 | ![[Pasted image 20240708082531.png]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                            | ns         |                 |
| [Maximum sum of non-adjacent elements (DP 5)](https://takeuforward.org/data-structure/maximum-sum-of-non-adjacent-elements-dp-5/)<br>House robber - cant rob adjacent house                                                                                                                 | ```<br> dp[i] = Math.max(dp[i-1], nums[i]+ dp[i-2] );<br>```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | ![[Pasted image 20240708083132.png]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | start with<br>```java<br> dp[0]=nums[0];<br>```<br>and<br>```java<br> dp[1]= Math.max(nums[0], nums[1]);<br>```<br>and then start the loop |            |                 |
| Kth largest element                                                                                                                                                                                                                                                                         | Use a min-heap of size k to store the k largest elements seen so far. At the end, the root of the heap will be the k-th largest element. It will give a time complexity nlogk whereas sorting with gives nlogn                                                                                                                                                                                                                                                                                                                                                                               | Use Priority queue in java (defaults to min heap).<br>syntax:<br>minHeap.offer(n) // to add<br>minHeap.poll()// remove<br>//meanHeap.size()                                                                                                                                                                                                                                                                                                                                                                                                                      | Largest -> min heap<br>smallest -> max heap.<br><br>Also when size is about to exceed, we need to push element fist before poping          |            |                 |
| give array of K largest element                                                                                                                                                                                                                                                             | Maintain a min-heap of size k to track the k largest elements as you iterate through the array. After processing all elements, the heap will contain the k largest elements. (catch question is not asking the k largest to be sorted so heap)                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                            |            |                 |
| [Max Product Subarray](https://takeuforward.org/data-structure/maximum-product-subarray-in-an-array/)                                                                                                                                                                                       | To find the maximum product subarray, keep track of both the maximum and minimum products at each step, since a negative number can flip the sign and turn a small product into a large one. The key idea is to update these products as you iterate through the array, considering the current element, its product with the previous maximum, and its product with the previous minimum.                                                                                                                                                                                                   | ```java<br>      int temp = Math.max(arr[i],Math.max(prod1*arr[i],prod2*arr[i]));<br>        prod2 = Math.min(arr[i],Math.min(prod1*arr[i],prod2*arr[i]));<br>        prod1 = temp;<br>        <br>        result = Math.max(result,prod1);<br>```                                                                                                                                                                                                                                                                                                               |                                                                                                                                            |            |                 |
| Longest Increasing Subsequence                                                                                                                                                                                                                                                              | To solve the Longest Increasing Subsequence (LIS), create an array `dp` where each element at index `i` stores the length of the longest subsequence that ends at `i`. For each element in the original array, iterate over all previous elements to check if the current element can extend any previous subsequence (i.e., if it’s larger than the previous element). If it can, update `dp[i]` to be the maximum of its current value or the length of the subsequence ending at the previous element plus one. Finally, the maximum value in the `dp` array gives the length of the LIS. | ```<br>int notTake = 0 + getAns(arr, n, ind + 1, prev_index, dp);<br><br>        int take = 0;<br><br>        if (prev_index == -1 \|\| arr[ind] > arr[prev_index]) {<br>            take = 1 + getAns(arr, n, ind + 1, ind, dp);<br>        }<br><br>        dp[ind][prev_index + 1] = Math.max(notTake, take);<br>```<br><br>or iterative solution<br><br> for (int i = 1; i < n; i++)<br>            for (int prev = 0; prev < i; prev++)<br>                if (arr[i] > arr[prev] && lis[i] < lis[prev] + 1)<br>                    lis[i] = lis[prev] + 1; |                                                                                                                                            |            |                 |
| <br>[Longest Common Subsequence](https://takeuforward.org/data-structure/longest-common-subsequence-dp-25/)                                                                                                                                                                                 | create a 2D array `dp` where `dp[i][j]` stores the length of the LCS of the first `i` characters of one string and the first `j` characters of the other. Fill the array by checking if characters match (add 1 to the value from the diagonal cell) or don’t match (take the maximum value from the cell above or to the left).                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                            |            |                 |
| [0-1 Knapsack](https://takeuforward.org/data-structure/0-1-knapsack-dp-19/)                                                                                                                                                                                                                 | create a 2D array `dp` where `dp[i][w]` represents the maximum value that can be achieved using the first `i` items with a total weight limit `w`. For each item, decide whether to include it by comparing the value of including it (current item value plus `dp` value of remaining capacity) versus excluding it (previous `dp` value).                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                            |            |                 |
| [Edit Distance](https://takeuforward.org/data-structure/edit-distance-dp-33/)                                                                                                                                                                                                               | ed to convert the first `i` characters of one string into the first `j` characters of the other. Fill the table by considering the cost of insertions, deletions, or substitutions, choosing the minimum operation at each step                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                            |            |                 |
| Maximum sum increasing subsequence                                                                                                                                                                                                                                                          | This problem is a variation of the standard [Longest Increasing Subsequence (LIS) problem](https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/). We need a slight change in the Dynamic Programming solution of [LIS problem](https://www.geeksforgeeks.org/longest-increasing-subsequence-dp-3/). All we need to change is to use sum as a criteria instead of a length of increasing subsequence.                                                                                                                                                                           | `/* Compute maximum sum values` <br><br>    `in bottom up manner */`<br><br>    `for` `( i = 1; i < n; i++ )` <br><br>        `for` `( j = 0; j < i; j++ )` <br><br>            `if` `(arr[i] > arr[j] &&` <br><br>                `msis[i] < msis[j] + arr[i])` <br><br>                `msis[i] = msis[j] + arr[i];`                                                                                                                                                                                                                                           |                                                                                                                                            |            |                 |
| [Matrix Chain Multiplication](https://takeuforward.org/dynamic-programming/matrix-chain-multiplication-dp-48/)<br><br>**Partition DP**                                                                                                                                                      | array `dp` where `dp[i][j]` represents the minimum number of scalar multiplications needed to compute the product of matrices from index `i` to `j`. Fill the table by splitting the chain at every possible position and combining the results to find the minimum cost.                                                                                                                                                                                                                                                                                                                    | dp[i][j] = min(dp[i][k] + dp[k+1][j] + p[i-1]*p[k]*p[j])<br><br>Whenever we need to find the answer to a large problem such that the problem can be broken into subproblems and the final answer varies due to the **order** in which the subproblems are solved.<br>                                                                                                                                                                                                                                                                                            |                                                                                                                                            |            |                 |
| [Minimum sum path in the matrix, (count paths and similar type do, also backtrack to find the Minimum path)](https://takeuforward.org/data-structure/minimum-path-sum-in-a-grid-dp-10/)<br>Minimum Path Sum In a Grid (DP 10)                                                               | To solve the Minimum Path Sum in a Grid using dynamic programming, create a 2D array `dp` where `dp[i][j]` stores the minimum path sum to reach cell `(i, j)`. Fill the array by adding the current cell's value to the minimum of the values from the cell above or to the left, with the base case being the starting cell at `dp[0][0]`.                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | ![[Pasted image 20240824144142.png]]<br>![[Pasted image 20240824144333.png]]                                                               |            |                 |
| **Coin Change 2**<br><br> infinite supply of each coin denomination<br><br>number of ways we can get the target                                                                                                                                                                             | creating a 1D array `dp` where `dp[i]` represents the number of ways to make amount `i`. Iterate over each coin, and for each coin, update the `dp` array by adding `dp[i - coin]` to `dp[i]`, which accounts for including the current coin in making up the amount.                                                                                                                                                                                                                                                                                                                        | dp = [0] * (amount + 1)<br>dp[0] = 1 # Base case: one way to make amount 0<br><br>for coin in coins: <br>for i in range(coin, amount + 1): <br>dp[i] += dp[i - coin]                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                            |            |                 |
| Subset sum equal k                                                                                                                                                                                                                                                                          | creating a 1D array `dp` where `dp[i]` is `True` if a subset sum of `i` is possible. Iterate through each number in the set, and for each number, update the `dp` array backwards from `K` to the number's value, setting `dp[i]` to `True` if `dp[i - num]` is `True`.                                                                                                                                                                                                                                                                                                                      | ![[Pasted image 20240824162421.png]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                            |            |                 |
| **Rod Cutting Problem**<br><br>We are given a rod of size ‘N’. It can be cut into pieces. Each length of a piece has a particular price given by the price array. Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces. | create an array `dp` where `dp[i]` represents the maximum revenue obtainable by cutting a rod of length `i`. For each length `i`, iterate through all possible cut lengths, updating `dp[i]` as the maximum of `dp[i]` and the sum of the price of the current cut plus `dp` of the remaining rod length<br><br>def rod_cutting(prices, n):<br>    dp = [0] * (n + 1)<br>    <br>    for i in range(1, n + 1):<br>        for j in range(1, i + 1):<br>            dp[i] = max(dp[i], prices[j - 1] + dp[i - j])<br>    <br>    return dp[n]<br>                                             | ![[Pasted image 20240824162647.png]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                            |            |                 |
| **Egg Dropping**<br>highest floor from which an egg can be dropped without breaking, given a certain number of eggs and a building with a specified number of floors.                                                                                                                       | To solve the Egg Dropping problem using dynamic programming, create a 2D array `dp` where `dp[k][n]` represents the minimum number of trials needed to find the critical floor with `k` eggs and `n` floors. For each `k` and `n`, calculate the minimum of the worst-case scenario by dropping the egg from each floor and considering both outcomes—egg breaks or doesn't break—using the formula `dp[k][n] = min(1 + max(dp[k-1][x-1], dp[k][n-x]))` for all possible floors `x`.                                                                                                         | - **`dp[k-1][x-1]`**: Represents the scenario where the egg breaks, so you move to the lower floors with one less egg.<br>- **`dp[k][n-x]`**: Represents the scenario where the egg doesn't break, so you check the higher floors with the same number of eggs.                                                                                                                                                                                                                                                                                                  |                                                                                                                                            | NS         |                 |
| Work break problem<br><br>you are given a string and a dictionary of words, and you need to determine if the string can be segmented into a sequence of one or more dictionary words.                                                                                                       | To solve the Word Break problem, use dynamic programming by creating a boolean array `dp` where `dp[i]` is `True` if the substring `s[0:i]` can be segmented into valid dictionary words. For each position `i`, check all possible substrings `s[j:i]` (where `0 ≤ j < i`), and if `dp[j]` is `True` and `s[j:i]` is in the dictionary, set `dp[i]` to `True`.                                                                                                                                                                                                                              | def word_break(s, word_dict):<br>    dp = [False] * (len(s) + 1)<br>    dp[0] = True  # Empty string can always be segmented<br>    <br>    for i in range(1, len(s) + 1):<br>        for j in range(i):<br>            if dp[j] and s[j:i] in word_dict:<br>                dp[i] = True<br>                break<br>    <br>    return dp[len(s)]<br>                                                                                                                                                                                                          |                                                                                                                                            |            |                 |
| Palindrome Partitioning (MCM Variation)<br><br>need to partition a string into the fewest number of palindromic substrings, or determine all possible palindromic partitions                                                                                                                | To solve the Palindrome Partitioning problem using dynamic programming, create a 2D array `dp` where `dp[i][j]` is `True` if the substring `s[i:j+1]` is a palindrome. Then, use a 1D array `cuts` where `cuts[i]` represents the minimum number of cuts needed to partition the substring `s[0:i+1]` into palindromic substrings, updating `cuts[i]` based on the palindromic substrings found using the `dp` table.                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                            |            |                 |
| **Maximum profit in Job scheduling**<br>problem involves scheduling jobs to maximize the total profit, subject to constraints on job deadlines and durations. Each job has a deadline by which it must be completed, and a profit associated with it.                                       | To solve the Maximum Profit in Job Scheduling problem using dynamic programming, create a DP table where `dp[i]` represents the maximum profit achievable by scheduling jobs up to the `i`-th deadline. Update the table by iterating through each job, and for each job, consider the maximum profit by either including or excluding the job based on its deadline and profit.                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                            |            |                 |



Heap 
https://takeuforward.org/interviews/strivers-sde-sheet-top-coding-interview-problems/


| Question                                                                                       | Hint to remember                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Coding hint                                                                                                                                                                                                                                                                              | Misktake to avoid                                                                                                                 | Not solved |
| ---------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------- | ---------- |
| Kth largest element                                                                            | Use a min-heap of size k to store the k largest elements seen so far. At the end, the root of the heap will be the k-th largest element. It will give a time complexity nlogk whereas sorting with gives nlogn                                                                                                                                                                                                                                                                                                                     | Use Priority queue in java (defaults to min heap).<br>syntax:<br>minHeap.offer(n) // to add<br>minHeap.poll()// remove<br>//meanHeap.size()                                                                                                                                              | Largest -> min heap<br>smallest -> max heap.<br><br>Also when size is about to exceed, we need to push element fist before poping |            |
| give array of K largest element                                                                | Maintain a min-heap of size k to track the k largest elements as you iterate through the array. After processing all elements, the heap will contain the k largest elements. (catch question is not asking the k largest to be sorted so heap)                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                          |                                                                                                                                   |            |
| find median in Stream of number                                                                | Medium can always be calculated in sorted Array.<br>Create 2 heaps, small number heal and large numbers heap. <br>                                                                                                                                                                                                                                                                                                                                                                                                                 | Maintain two heaps, one max-heap for smaller half of numbers and one min-heap for larger half. Ensure heaps are balanced for efficient median calculation.                                                                                                                               |                                                                                                                                   |            |
| [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)              | Use a max-heap (priority queue) to maintain the k closest elements to the target, comparing their absolute distances. If the heap size exceeds k, remove the element with the largest distance, then sort the result before returning.                                                                                                                                                                                                                                                                                             | absolute difference of each element with the target element                                                                                                                                                                                                                              |                                                                                                                                   |            |
| Merge k sorted list<br>https://leetcode.com/problems/merge-k-sorted-lists/description/         | Use a priority queue to keep track of the smallest nodes across all the lists. Continuously extract the smallest node, add it to the merged list, and then add the next node from the same list to the queue until all nodes are processed.                                                                                                                                                                                                                                                                                        | First add all the head notes of linked list                                                                                                                                                                                                                                              |                                                                                                                                   |            |
| Maximum sum combinations<br>https://www.interviewbit.com/problems/maximum-sum-combinations/    | - **Sort and Initialize**: Sort both input arrays in descending order, then use a max-heap (priority queue) to keep track of the maximum sums along with their indices.<br>- **Track and Process**: Insert the initial sum of the first elements of both arrays into the heap and use a set to track visited index pairs to avoid duplicates.<br>- **Iterate and Extract**: Repeatedly extract the maximum sum from the heap and add the next possible sums from the arrays until you have the desired number of top combinations. | Sort both arrays. If we have to get k sum. Create of a loop of k. Before loop initial with first value of both sorted array and also mark it visited. Then in the loop of k, pop one element out of heap and add it to ans and insert two element (i+1,j) and (i,j+1) with visited check | to mark visited use i+"_"+j string set                                                                                            |            |
| k most frequent element<br>eg. **Input:** nums = [1,1,1,2,2,3], k = 2<br>**Output:** [1,2]<br> | - Use a hash map to count the frequency of each element.<br>- Push elements into a min-heap of size k based on frequency, then extract the heap's elements.                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                          |                                                                                                                                   |            |


