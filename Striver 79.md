| Question[]()                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | Hint to remember                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Coding hint                                                                                                                                                                                                                                                                                                                                                                                                 | Misktake to avoid | Not solved | Revision needed |
| ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------- | ---------- | --------------- |
| Arrays and Hashing                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| <br>\|[Next Permutation](https://takeuforward.org/data-structure/next_permutation-find-next-lexicographically-greater-permutation/)\|<br><br>generating the next lexicographical permutation of a given sequence of numbers<br>eg. 1,2,3 will be 1,3,2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | 1. **Identify the Pivot**: Traverse the array from right to left and find the first index ii where A[i]<A[i+1]A[i]<A[i+1]. This index ii is called the pivot.<br>2. **Find Successor**: If a pivot was found, find the largest index jj greater than ii such that A[j]>A[i]A[j]>A[i].<br>3. **Swap**: Swap the elements at indices ii and jj.<br>4. **Reverse Suffix**: Reverse the sequence from index i+1i+1 to the end of the array to get the next smallest lexicographic order.<br>5. **Handle Edge Case**: If no pivot is found (the entire array is non-increasing), simply reverse the entire array.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Majority element(n/3 times)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | we can use a modified version of **Moore's Voting Algorithm**.<br><br><br>1. **Initialization**: We can have up to two potential candidates since no more than two elements can appear more than n/3n/3 times in an array of size nn.<br>2. **Candidate Selection**:<br>    <br>    - Traverse through the array and maintain two candidate variables and their respective counts.<br>    - For each element:<br>        <br>        - If it matches one of the candidates, increment the corresponding count.<br>        - If a count reaches zero, replace the candidate with the current element and reset its count to one.<br>        - If it does not match either candidate, decrement both counts.<br>        <br>    <br>3. **Validation**: After identifying potential candidates, traverse the array again to validate if either candidate appears more than n/3n/3 times.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Count number of subarrays with given xor K](https://takeuforward.org/data-structure/count-the-number-of-subarrays-with-given-xor-k/)<br>You are given an array of integers and a target value KKK. The task is to find the count of subarrays whose XOR equals KKK.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | - Create a hash map to store counts of prefix XORs.<br>- Update `currentXOR` with the current element.<br>- Check if `currentXOR ^ k` exists in the hash map. If it does, add its count to our result.<br>- If `currentXOR` equals KK, increment the count.<br>- Update the hash map with `currentXOR`.<br>Video link for revision: https://www.youtube.com/watch?v=eZr-6p0B7ME<br><br><br><br>[[SubArray XOR sum equal K.md]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Lets say numbers are a,b,c,d,e,f and number we have to make is k<br><br>if we have to find if c^d^e = k just using prefix sum<br><br>we use prefix till e, ie a^b^c^d^e<br>and then xor it with prefix till b ie a^b<br>and a,b will cancel each other<br><br>2nd thing we need to understand is a,b,c,d,e xor with k prefix is equal to a^b then its same thing. So using hashmap we can achieve the same. |                   |            | Y               |
| [Count Inversions](https://takeuforward.org/data-structure/count-inversions-in-an-array/)<br><br>Counting the number of "inversions" in an array.<br><br>### What is an Inversion?<br><br>In an array, an inversion is defined as a pair of indices (i,j)(i, j)(i,j) such that:<br><br>- i<ji < ji<j and<br>- arr[i]>arr[j]arr[i] > arr[j]arr[i]>arr[j].<br><br>### Example 1:<br><br>Input: `arr = [2, 4, 1, 3, 5]`<br><br>**Explanation**: The inversions are:<br><br>- (2, 1): arr[0] > arr[2]<br>- (4, 1): arr[1] > arr[2]<br>- (4, 3): arr[1] > arr[3]<br><br>Total inversions = 3.<br><br>Output: `3`<br><br>                                                                                                                                                                      | This count indicates how far the array is from being sorted. The most efficient way to count inversions is by using a modified merge sort algorithm.<br><br>## Steps to Solve the Problem<br><br>1. **Divide and Conquer**: Use the merge sort technique to divide the array into two halves recursively until each half contains a single element.<br>2. **Count Inversions During Merge**: While merging two halves, count how many times elements from the right half are less than elements from the left half. Each time this occurs, it indicates that all remaining elements in the left half will also form inversions with that element from the right half.<br>3. **Combine Counts**: The total number of inversions is the sum of inversions found in the left half, right half, and during the merging process.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Maximum Product Subarray](https://takeuforward.org/data-structure/maximum-product-subarray-in-an-array/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | To find the maximum product subarray efficiently, maintain both maximum and minimum products at each index while iterating through the array. Swap these values when encountering a negative number to account for potential maximum products.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Binary search<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Search in Rotated Sorted Array II](https://takeuforward.org/arrays/search-element-in-rotated-sorted-array-ii/)\|<br><br>(Duplicated are allowed)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | - **Modified binary search with additional checks**:<br>    - Duplicates can make it harder to decide which half of the array is sorted.<br>    - To handle this, when nums[start]==nums[mid]==nums[end]nums[start] == nums[mid] == nums[end]nums[start]==nums[mid]==nums[end], increment startstartstart or decrement endendend to skip duplicates. This reduces the array size.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Find minimum in Rotated Sorted Array](https://takeuforward.org/data-structure/minimum-in-rotated-sorted-array/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | **Key Insight**:<br><br>- In a rotated sorted array, one half is always sorted.<br>- The minimum element lies in the unsorted half.<br><br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Find peak element](https://takeuforward.org/data-structure/peak-element-in-array/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | - Find the middle element `mid = (low + high) / 2`.<br>- If `nums[mid]` is greater than its neighbors (`nums[mid-1]` and `nums[mid+1]`), then it's a peak, and you can return it.<br>- If `nums[mid]` is smaller than `nums[mid+1]`, move your search to the right half by setting `low = mid + 1`.<br>- If `nums[mid]` is smaller than `nums[mid-1]`, move your search to the left half by setting `high = mid - 1`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Koko Eating Bananas](https://takeuforward.org/binary-search/koko-eating-bananas/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Set `low = 1` (minimum speed) and `high = max(piles)` (maximum speed, i.e., eating all bananas in one hour).<br>- Calculate the mid-point speed: `mid = (low + high) / 2`.<br>- Check if Koko can finish all bananas in the given time at this speed:<br>    - For each pile, calculate the time it takes to eat at speed `mid` (use `ceil(pile / mid)` for each pile).<br>    - Sum the times for all piles and check if the total time is less than or equal to the given time `h`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Aggressive Cows](https://takeuforward.org/data-structure/aggressive-cows-detailed-solution/)\|<br><br>You are given an array **'arr'** of size **'n'** which denotes the position of stalls.  <br>You are also given an integer **'k'** which denotes the number of aggressive cows.  <br>You are given the task of assigning stalls to **'k'** cows such that the minimum distance between any two of them is the maximum possible.<br>k = 3, arr[] = {0,3,4,7,10,9}<br><br>**Explanation:** The maximum possible minimum distance between any two cows will be 3 when 4 cows are placed at positions {0, 3, 7, 10}. Here the distances between cows are 3, 4, and 3 respectively. We cannot make the minimum distance greater than 3 in any ways. | Step 2: Binary Search Setup<br>Set up a binary search to find the maximum minimum distance:<br>	•	Low: Start with 1 (the smallest possible distance).<br>	•	High: Set this to the difference between the maximum and minimum stall positions.<br><br><br>Step 3: Check Feasibility Function<br>Create a function `canPlaceCows` that checks if it’s possible to place all cows with at least a given minimum distance:<br>	•	Place the first cow in the first stall.<br>	•	For each subsequent cow, check if it can be placed in a stall that is at least `mid` distance away from the last placed cow.<br>	•	If you can place all  cows, return true; otherwise, return false                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Book Allocation Problem](https://takeuforward.org/data-structure/allocate-minimum-number-of-pages/)<br><br> Given an array ‘arr of integer numbers, ‘ar[i]’ represents the number of pages in the ‘i-th’ book. There are a ‘m’ number of students, and the task is to allocate all the books to the students.  <br>Allocate books in such a way that:<br><br>1. Each student gets at least one book.<br>2. Each book should be allocated to only one student.<br>3. Book allocation should be in a **contiguous manner**.<br>                                                                                                                                                                                                                                                           | - **Binary Search on the Answer:**<br>    <br>    - The possible range for the maximum pages is between:<br>        - **Low**: The maximum number of pages in a single book (`max(pages)`).<br>        - **High**: The sum of all pages (`sum(pages)`).<br>    - Use binary search to find the minimum feasible value of the maximum pages.<br>- **Helper Function to Check Feasibility:**<br>    <br>    - A function `isFeasible(pages, M, maxPages)` checks if it's possible to allocate books to MMM students such that no student gets more than `maxPages`.<br>- **Steps:**<br>    <br>    - Initialize `low = max(pages)` and `high = sum(pages)`.<br>    - Perform binary search:<br>        - Compute `mid = (low + high) // 2`.<br>        - Check feasibility with `isFeasible`.<br>            - If feasible, move `high = mid`.<br>            - Otherwise, move `low = mid + 1`.<br>    - Return `low` as the result.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Median of 2 sorted arrays](https://takeuforward.org/data-structure/median-of-two-sorted-arrays-of-different-sizes/)<br>means, on left and right there will be equal number of elements after sorted merge                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | ![[images/Pasted image 20241202125147.png]]<br>To find the median of two sorted arrays, use binary search on the smaller array to determine a partition that divides both arrays into two halves. Ensure that all elements on the left side of the partitions are less than or equal to those on the right side, adjusting the partitions as necessary. Finally, calculate the median based on whether the total number of elements is even or odd, using the maximum of the left sides and the minimum of the right sides.<br>**While doing the first partition, we split smaller array in half and they bigger one, size of both minus size of small one to keep it balanced and to be at middle**.<br>Keep shifting the smaller array left right, and check with the bigger array new left right calculated using smaller one's new left right.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Minimize Max Distance to Gas Station](https://takeuforward.org/arrays/minimise-maximum-distance-between-gas-stations/)<br>**Problem Statement:** You are given a sorted array ‘arr’ of length ‘n’, which contains positive integer positions of ‘n’ gas stations on the X-axis. You are also given an integer ‘k’. You have to place 'k' new gas stations on the X-axis. You can place them anywhere on the non-negative side of the X-axis, even on non-integer positions. Let 'dist' be the maximum value of the distance between adjacent gas stations after adding k new gas stations.  <br>Find the minimum value of ‘dist’.                                                                                                                                                       | To solve the **Minimize Max Distance to Gas Station** problem, use **binary search** to find the smallest possible maximum distance between gas stations. Define the search range as [0,max_distance][0, max\_distance][0,max_distance], where max_distancemax\_distancemax_distance is the maximum distance between two adjacent stations. For a given candidate maximum distance midmidmid, check if it is feasible by counting the additional stations needed to make all gaps ≤mid \leq mid≤mid. Adjust the search range based on feasibility: if feasible, reduce midmidmid; otherwise, increase it.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| **Linked List**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Middle of a LinkedList [TortoiseHare Method]](https://takeuforward.org/data-structure/find-middle-element-in-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | To find the middle of a linked list, use the **two-pointer approach**. Move one pointer (`slow`) one step at a time and another pointer (`fast`) two steps at a time; when the `fast` pointer reaches the end, the `slow` pointer will be at the middle. This approach works in O(n)O(n)O(n) time with O(1)O(1)O(1) space, regardless of whether the list has an odd or even number of nodes.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Detect a loop in LL](https://takeuforward.org/data-structure/detect-a-cycle-in-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | To detect a loop in a linked list, you can use Floyd’s Cycle-Finding Algorithm, which employs two pointers: a slow pointer that moves one step at a time and a fast pointer that moves two steps at a time. If there is a loop, the fast pointer will eventually meet the slow pointer; if the fast pointer reaches the end of the list (null), then there is no loop. Once a loop is detected, you can find the starting point of the loop by resetting one pointer to the head of the list and moving both pointers one step at a time until they meet again                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Remove Nth node from the back of the LL](https://takeuforward.org/data-structure/remove-n-th-node-from-the-end-of-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | To remove the Nth node from the end of a linked list, you can use a two-pointer approach. First, initialize two pointers, `fast` and `slow`, both pointing to the head of the list; then move the `fast` pointer N steps ahead. After that, move both pointers simultaneously until the `fast` pointer reaches the end of the list, at which point the `slow` pointer will be positioned just before the Nth node from the end, allowing you to adjust the pointers to remove that node                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Find the intersection point of Y LL](https://takeuforward.org/data-structure/find-intersection-of-two-linked-lists/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | To find the intersection point of two linked lists, you can use a two-pointer technique. Start by initializing two pointers at the heads of both lists and traverse them until they either meet or both reach the end; if one pointer reaches the end, redirect it to the head of the other list. This way, both pointers will traverse the same total distance, allowing them to meet at the intersection point if one exists, or both will reach null if there is no intersection.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Sort LL                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | To sort a linked list, you can use the Merge Sort algorithm, which is efficient for linked lists due to its ability to split and merge without requiring additional space for arrays. First, recursively split the linked list into two halves until you reach base cases of single nodes, then merge the sorted halves back together by comparing the values of the nodes. This approach maintains a time complexity of  and is stable, preserving the relative order of equal elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Segrregate odd and even nodes in LL](https://takeuforward.org/data-structure/segregate-even-and-odd-nodes-in-linkedlist)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | To segregate odd and even nodes in a linked list, you can create two separate lists: one for odd nodes and one for even nodes. Traverse the original linked list, appending each node to either the odd list or the even list based on its value, and keep track of the last node in each list to facilitate easy linking. **Finally, connect the end of the odd list to the head of the even list and set the tail of the even list to `null` to complete the segregation.**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| **Recursion and BackTracking**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Print all the possible subsequences of the String<br>**Input:** str = "abc"<br>**Output:** a ab abc ac b bc c<br>**Explanation:** Printing all the 7 subsequence for the string "abc".                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | To print all possible subsequences of a string using recursion, you can define a recursive function that explores two choices for each character: including it in the current subsequence or excluding it. Start with an empty subsequence and iterate through the string, making recursive calls to generate subsequences for both scenarios until you reach the end of the string. When you hit the base case (end of the string), print the current subsequence if it’s not empty, and backtrack to explore other combinations.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Combination Sum](https://takeuforward.org/data-structure/combination-sum-1/)\|<br>Given an array of distinct integers and a **target**, you have to return _the list of all unique combinations where the chosen numbers sum to_ target_._                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | To solve the Combination Sum problem, use a backtracking approach where you recursively explore combinations of the given candidates that sum to a specified target. Start with an empty path and iterate through the candidates, adding each candidate to the current combination while keeping track of the current sum. If the current sum matches the target, add the combination to the results; if it exceeds the target, backtrack and continue exploring other candidates.<br><br>the best time complexity for this is e , where  is the target sum and  is the average length of the combinations found. <br>We can use DP to improve the solution if we are just asked number of ways to reach target.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[N Queen](https://takeuforward.org/data-structure/n-queen-problem-return-all-distinct-solutions-to-the-n-queens-puzzle/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | To solve the N-Queens problem, use a backtracking approach where you place queens one by one in different columns of the chessboard while ensuring that no two queens threaten each other. Start by placing a queen in the first column and recursively attempt to place queens in subsequent columns, checking for conflicts with previously placed queens in the same row, column, or diagonal. If placing a queen leads to a conflict, backtrack by removing the last placed queen and try the next possible position until all queens are successfully placed or all configurations have been exhausted.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Sudoko Solver](https://takeuforward.org/data-structure/sudoku-solver/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | To solve the Sudoku Solver problem, you can use a backtracking algorithm that recursively fills empty cells in the 9x9 grid with numbers from 1 to 9. The algorithm involves checking if placing a number in a cell is valid by ensuring it does not violate Sudoku rules (no duplicates in the same row, column, or 3x3 subgrid). If a number can be placed, the algorithm continues to the next empty cell; if it encounters a situation where no number can be placed, it backtracks by removing the last placed number and tries the next possibility until the entire board is filled correctly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [M Coloring Problem](https://takeuforward.org/data-structure/m-coloring-problem/)<br>Given an undirected graph and a number m, determine if the graph can be colored with at most m colors such that no two adjacent vertices of the graph are colored with the same color.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | To solve the M-Coloring Problem, we can use a backtracking algorithm that assigns colors to the vertices of a graph while ensuring that no two adjacent vertices share the same color. Begin by creating a recursive function that attempts to color each vertex starting from the first one, checking if the current color assignment is safe (i.e., it does not conflict with adjacent vertices). If a valid color is found, recursively attempt to color the next vertex; if all vertices are colored successfully, return true. If no valid color can be assigned to a vertex, backtrack by removing the last assigned color and trying the next available color until all possibilities are exhausted or a solution is found.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Word Search](https://takeuforward.org/data-structure/word-search-leetcode/)\|<br>Given an **m x n** **grid of characters** board and a **string word**, return **true if the word exists** in the grid.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | To solve the Word Search problem, employ a backtracking algorithm that explores each cell in the grid as a potential starting point for the word. Begin by iterating through each cell, and if the cell matches the first letter of the word, recursively check its adjacent cells (up, down, left, right) for the subsequent letters while marking cells as visited to avoid reusing them. If you reach the end of the word successfully, return true; otherwise, backtrack by unmarking the visited cells and continue searching until all possibilities are exhausted.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| **Stacks And queues**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Next Greater Element<br>Given a circular integer array **A**, return the next greater element for every element in A. The next greater element for an element x is the first element greater than x that we come across while traversing the array in a clockwise manner. If it doesn't exist, return -1 for this element.<br>**Input:** N = 11, A[] = {3,10,4,2,1,2,6,1,7,2,9}<br><br>**Output:** 10,-1,6,6,2,6,7,7,9,9,10<br>                                                                                                                                                                                                                                                                                                                                                          | To solve this, use a **monotonic decreasing stack** to track indices of elements for which the next greater element hasn’t been found yet. Traverse the array twice (simulate the circular behavior by treating indices modulo nnn), and for each element, check if it is greater than the element at the top of the stack; if so, update the result for the index at the top. Push the current index onto the stack if its next greater element hasn't been determined. This approach ensures O(n)O(n)O(n) time complexity by limiting each element's processing to at most twice.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Trapping Rainwater](https://takeuforward.org/data-structure/trapping-rainwater/)<br>Given an array of non-negative integers representation elevation of ground. Your task is to find the water that can be trapped after rain.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Take 2 array prefix and suffix array and precompute the leftMax and rightMax for each index beforehand. Then use the formula min(prefix[I], suffix[i])-arr[i] to compute water trapped at each index.<br><br>Then compute <br>```waterTrapped += Math.min(prefix[i], suffix[i]) - arr[i];```                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Largest rectangle in a histogram](https://takeuforward.org/data-structure/area-of-largest-rectangle-in-histogram/)<br>Given an array of integers heights representing the histogram's bar height where the width of each bar is 1  return the area of the largest rectangle in histogram.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | **Key Idea:**<br><br>- For each bar in the histogram, determine the **leftmost** and **rightmost boundaries** where the height of bars is at least as tall as the current bar.<br>- The area of a triangle with base width and height equal to the current bar can then be computed.<br><br>**Use of Monotonic Stack:**<br><br>- **Stack stores indices** of the bars in increasing order of heights.<br>- As you iterate through the histogram, when encountering a bar shorter than the one represented by the top of the stack:<br>    - Pop the stack to calculate the **triangle's area** for the bar represented by the popped index.<br><br>**Boundary Calculation:**<br><br>- The **left boundary** is determined by the index stored in the stack just before the current bar.<br>- The **right boundary** is determined when the stack is popped for a shorter bar.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Asteroid Collision](https://takeuforward.org/interview-sheets/strivers-79-last-moment-dsa-sheet-ace-interviews)<br>We are given an array `asteroids` of integers representing asteroids in a row.<br><br>For each asteroid, the absolute value represents its size, and the sign represents its direction (positive meaning right, negative meaning left). Each asteroid moves at the same speed.<br><br>Find out the state of the asteroids after all collisions. If two asteroids meet, the smaller one will explode. If both are the same size, both will explode. Two asteroids moving in the same direction will never meet.                                                                                                                                                       | **Stack Mechanics**: Push asteroids into the stack when they won't collide, and pop from the stack during collisions, ensuring an efficient simulation.<br><br>To solve the Asteroid Collision problem, use a stack to manage the states of asteroids as you iterate through the input array. When encountering a left-moving asteroid (negative), check for potential collisions with right-moving asteroids (positive) stored in the stack, resolving collisions based on their sizes. The core concept is to simulate the collision process by using the stack to keep track of surviving asteroids after all possible collisions have been resolved.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Sliding Window maximum](https://takeuforward.org/data-structure/sliding-window-maximum/)<br> Given an array of integers arr, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return _the **max sliding window**_.                                                                                                                                                                                                                                                                                                                                                                                                        | ### Core Concept:<br><br>The deque maintains indices of array elements, ensuring:<br><br>1. **Decreasing Order**: Indices in the deque correspond to elements in decreasing order of value, ensuring the maximum element is always at the front.<br>2. **Window Validity**: Only indices within the current sliding window are kept in the deque.<br><br>Use a **deque** to store indices of elements in the sliding window, maintaining decreasing order of values. For each index, remove elements outside the window or smaller than the current value, then add the index. The front of the deque always holds the maximum, which is recorded after the first window forms.<br><br>if (!deque.isEmpty() && deque.peekFirst() < i - k + 1) { deque.pollFirst(); } // Remove indices whose corresponding values are smaller than nums[i]<br><br> while (!deque.isEmpty() && nums[deque.peekLast()] < nums[i]) { deque.pollLast(); }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [LRU cache (IMPORTANT)](https://takeuforward.org/data-structure/implement-lru-cache/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | A combination of a **hash map** and a **doubly linked list** is used to achieve this.<br><br>1. **Hash Map**: Stores the mapping of keys to nodes in the doubly linked list for O(1)O(1)O(1) access to the cache entries.<br>2. **Doubly Linked List**: Maintains the order of usage, with the most recently used element at the head and the least recently used at the tail.<br>    - When a key is accessed (`get` or `put`), move the corresponding node to the head.<br>    - When the cache is full, remove the node at the tail to evict the least recently used key.<br><br>How to move least recently used to head in efficient way?<br>-> Remove node (as we do un linkedin list)<br>-> add to head <br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Heap                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| kth largest element in an array                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Priority queue of size k (min heap)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Task Scheduler.<br>You are given an array of CPU `tasks`, each labeled with a letter from A to Z, and a number `n`. Each CPU interval can be idle or allow the completion of one task. Tasks can be completed in any order, but there's a constraint: there has to be a gap of **at least** `n` intervals between two tasks with the same label.<br>Return the **minimum** number of CPU intervals required to complete all tasks.                                                                                                                                                                                                                                                                                                                                                       | - **Count Frequencies**:<br>    <br>    - Use a frequency map (or array for 26 tasks) to count occurrences of each task.<br>- **Initialize Max-Heap**:<br>    <br>    - Push the frequencies of tasks into a max-heap, where the highest frequency is processed first.<br><br>**Simulate Task Execution**:<br><br>- Use a cooldown queue (or list) to track tasks that are waiting for their cooldown to expire.<br>- At each time step:<br>    - Pop a task from the max-heap, execute it, and reduce its remaining frequency.<br>    - If it has more executions left, add it to the cooldown queue with its cooldown expiration time.<br>    - Check if any task in the cooldown queue is ready to be pushed back into the heap.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| <br>\|\|Min Heap and Max Heap Implementation\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | [[min and max heap implementation]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| **BT+BST**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|\|[Diameter of Binary Tree](https://takeuforward.org/data-structure/calculate-the-diameter-of-a-binary-tree/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | ### Key Concepts:<br><br>1. **Height of a Node**: The height of a node is the number of edges on the longest path from that node to a leaf node.<br>    <br>2. **Diameter of the Tree**: The diameter is the longest path between any two nodes. This can be:<br>    <br>    - Through the root node.<br>    - Not necessarily through the root node.<br><br>### Key Insight:<br><br>- The diameter of the tree can be the sum of the heights of two subtrees of a node plus one edge that connects the two subtrees.<br>- **For each node**: the diameter through that node is the sum of the heights of its left and right subtrees.<br>- **Overall diameter**: Keep track of the maximum diameter encountered while traversing all the nodes.<br><br>**2nd way**<br><br>To find the diameter of a binary tree using Depth First Search (DFS), you can employ a two-pass DFS approach.<br>Steps to Solve Using DFS<br>	1.	First DFS Pass: Start from any arbitrary node (commonly the root) and perform a DFS to find the farthest node from it. Let’s call this node `A`.<br>	2.	Second DFS Pass: From node `A`, perform another DFS to find the farthest node from `A`, which we will call `B`. The distance between `A` and `B` represents the diameter of the tree.<br>	3.	Calculate Diameter: The diameter is determined by counting the number of edges in the path from `A` to `B`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Maximum path sum](https://takeuforward.org/data-structure/maximum-sum-path-in-binary-tree/)<br><br>A **path** in a binary tree is a sequence of nodes where each pair of adjacent nodes in the sequence has an edge connecting them. A node can only appear in the sequence **at most once**. Note that the path does not need to pass through the root.<br><br>The **path sum** of a path is the sum of the node's values in the path.<br><br>Given the `root` of a binary tree, return _the maximum **path sum** of any **non-empty** path_.                                                                                                                                                                                                                                          | The key concept to solve the Binary Tree Maximum Path Sum problem involves understanding that a path can start and end at any node in the tree, and it can traverse through multiple nodes without needing to pass through the root. The main insight is to use a recursive Depth-First Search (DFS) approach to calculate the maximum path sums at each node by considering the contributions from both its left and right subtrees, while also keeping track of the overall maximum path sum encountered during the traversal.<br><br>Key Insights:<br>	1.	Path Definition: A path in the binary tree is defined as a sequence of nodes connected by edges, where each node can only appear once in that sequence. The path does not have to include the root of the tree.<br>	2.	Recursive Calculation: For each node, compute the maximum path sum that can be achieved by including that node and extending to either its left or right child. This involves:<br>	•	Calculating the maximum path sums from both left and right children.<br>	•	Ignoring negative contributions by using `max(0, left_sum)` and `max(0, right_sum)` to ensure that only positive values are added to the current node’s value.<br>	3.	Global Maximum Tracking: Maintain a global variable to update the maximum path sum found at any point in the tree, which is computed as `node.val + left + right` for each node.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Bottom View of Binary Tree](https://takeuforward.org/data-structure/bottom-view-of-a-binary-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | ![[images/Pasted image 20241207133913.png]]Ans - [4, 5, 6, 3, 11]<br>To solve the Bottom View of a Binary Tree problem, you can use a breadth-first search (BFS) approach or a depth-first search (DFS) approach. The key insights for this problem involve tracking the horizontal distance (HD) of each node from the root and ensuring that you capture the last node encountered at each horizontal distance, as this will represent the bottom view.<br><br>### Key Insights:<br><br>1. **Horizontal Distance (HD)**:<br>    <br>    - The concept of **horizontal distance (HD)** is crucial for determining which nodes belong to the same vertical line.<br>    - The root node has an HD of `0`.<br>    - For each left child, the HD is the parent's HD minus 1.<br>    - For each right child, the HD is the parent's HD plus 1.<br><br>**Bottom View Property**:<br><br>- For nodes that share the same **horizontal distance**, the **bottommost node** is the one that is visible.<br>- If multiple nodes have the same HD, the one encountered last in a **level-order traversal (BFS)** will be the bottommost node.<br><br>**Level Order Traversal (BFS)**:<br><br>- To ensure we capture the bottommost node at each horizontal distance, we use a **BFS (level-order traversal)**. This ensures that we visit the nodes from top to bottom, left to right.<br>- For each node, if its HD is not already recorded, we add it to the map. If it's already present, we update the value to the current node (this ensures the bottommost node is recorded).<br><br>**Use of a HashMap**:<br><br>- A **HashMap** is used to store the **HD** as the key and the node value as the value.<br>- As we traverse the tree, we continuously update the value for each HD, ensuring only the bottommost node (the last one encountered in BFS) is stored.<br><br>### Approach:<br><br>1. Perform a **Level-Order Traversal** (BFS) to explore nodes from top to bottom.<br>2. For each node, compute its **HD** and store it in a **HashMap**.<br>3. Once the traversal is done, extract the values from the **HashMap** in increasing order of the HD to get the **Bottom View**.<br><br>### Hint for the Code:<br><br>1. Use a **Queue** for BFS traversal. Each entry in the queue will store a pair of node and its corresponding HD.<br>2. Use a **HashMap<Integer, Integer>** where the key is the **HD** and the value is the node's value at that HD.<br>3. After BFS traversal, iterate over the keys of the map in sorted order to print the bottom view.                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [LCA in Binary Tree](https://takeuforward.org/data-structure/lowest-common-ancestor-for-two-given-nodes/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | There is can be multiple common ancestors but there willl be only one LCA. In the LCA node, the childs will be found on either side else it will be found only on one side. <br><br>so while doing recursion on both side of tree, the node where we found the left and right tree on either side is our LCA.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Minimum time taken to BURN the Binary Tree from a Node                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | the idea is to model the spread of fire starting from a given node. The fire spreads one level at a time to adjacent nodes (parent, left child, right child).<br><br>- -traverse the tree using DFS and record the parent of each node. This allows us to treat the tree as a graph for BFS traversal.<br>- **Burn Simulation**:<br>    <br>    - Start BFS from the target node.<br>    - For each node, add its unvisited neighbors (left child, right child, and parent) to the queue.<br>    - Increase time whenever the fire spreads to a new level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Construct Binary Tree from inorder and preorder](https://takeuforward.org/data-structure/construct-a-binary-tree-from-inorder-and-preorder-traversal/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | ### Key Insights:<br><br>1. **Preorder Traversal**:<br>    <br>    - In preorder traversal, the root node of the tree or subtree is always the first element.<br>    - This helps identify the root node of the current subtree being constructed.<br>2. **Inorder Traversal**:<br>    <br>    - In inorder traversal, the nodes are arranged in the sequence **left subtree → root → right subtree**.<br>    - This helps determine the boundary of the left and right subtrees for the current root.<br>3. **Divide and Conquer**:<br>    <br>    - Use the first element of the preorder traversal to identify the root.<br>    - Locate the root in the inorder traversal to split it into the left and right subtrees.<br>    - Recursively repeat the process for the left and right subtrees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Morris Preorder Traversal of a Binary Tree](https://takeuforward.org/data-structure/morris-preorder-traversal-of-a-binary-tree/)<br>**preorder traversal** of a binary tree without using **recursion** or **explicit stack space** while preserving **O(n)** time complexity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Uses concept of threaded binary tree.<br><br>What is inorder? L Ro Ri<br><br>To perform **Morris Preorder Traversal**, the key concept is to use **temporary threads** to connect the current node to its **inorder predecessor** in the tree, allowing traversal without recursion or an auxiliary stack. The traversal process uses a pointer to the left child when available, and otherwise moves to the right child                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Delete a Node in Binary Search Tree                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | The node to delete can fall into one of three cases:<br><br>1. **Node has no children (leaf node)**:<br>    <br>    - Simply remove the node by setting its parent’s pointer to `null`.<br>2. **Node has one child**:<br>    <br>    - Replace the node with its only child (either left or right).<br>3. **Node has two children**:<br>    <br>    - Find the **inorder successor** (the smallest node in the right subtree) or **inorder predecessor** (the largest node in the left subtree).<br>    - Replace the value of the node to be deleted with the successor’s or predecessor’s value.<br>    - Delete the successor or predecessor node (which will now fall into one of the first two cases).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| LCA in BST                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | In a BST:<br><br>1. All nodes in the left subtree of a node have values **less than the node’s value**.<br>2. All nodes in the right subtree of a node have values **greater than the node’s value**.<br><br>Using this property:<br><br>- If both ppp and qqq are **smaller** than the current node, their LCA lies in the **left subtree**.<br>- If both ppp and qqq are **greater** than the current node, their LCA lies in the **right subtree**.<br>- If ppp and qqq split (i.e., one is on the left and the other is on the right) or one equals the current node, the current node is the LCA.<br><br>### **Algorithm**:<br><br>1. Start from the root of the BST.<br>2. Compare the values of ppp and qqq with the current node:<br>    - If ppp and qqq are **both smaller**, move to the left child.<br>    - If ppp and qqq are **both greater**, move to the right child.<br>    - Otherwise, return the current node as the LCA.<br>3. Repeat until you find the LCA.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Two Sum In BST \| Check if there exists a pair with Sum K                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | **Key Concepts**:<br>Easy way: Inorder traversal of a BST gives nodes in **sorted order**.<br><br>**If we have to solve this without extra space:**<br>The **most optimal way** to solve the **Two Sum in BST** problem is the **Two Pointers Without Extra Space** approach<br>Only two stacks are used to simulate the two pointers, each having at most hhh elements, where hhh is the height of the BST. This is much better than storing all nodes (like in the Inorder + Two Pointers approach) or a hash set.<br><br>Algo<br><br>- Simulate two pointers:<br>    1. **Left pointer**: Starts from the smallest element (inorder traversal).<br>    2. **Right pointer**: Starts from the largest element (reverse inorder traversal).<br>- Compare the sum of the two pointers with KKK:<br>    - If the sum equals KKK, return `true`.<br>    - If the sum is smaller than KKK, move the left pointer forward (like incrementing in sorted order).<br>    - If the sum is larger than KKK, move the right pointer backward (like decrementing in sorted order).<br>- Stop when the two pointers cross.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Largest BST in Binary Tree                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | This requires checking each subtree of the binary tree to see if it's a BST,<br><br>A **postorder traversal** is an optimal approach for this problem. This allows us to traverse the tree from the leaves to the root, ensuring that when we check if a subtree is a BST, we already have information about its children.<br><br>**Tracking Information for Each Node**:<br><br>- For each node, we need to keep track of:<br>    - **Size of the subtree** (number of nodes).<br>    - **Minimum value** in the subtree.<br>    - **Maximum value** in the subtree.<br>    - **Whether the subtree is a valid BST**.<br><br>To solve the **Largest BST in Binary Tree** problem optimally, the goal is to find the size of the largest Binary Search Tree (BST) subtree within a given Binary Tree. This requires checking each subtree of the binary tree to see if it's a BST, and if so, calculating its size.<br><br>### **Key Concepts**:<br><br>1. **BST Properties**:<br>    <br>    - A **Binary Search Tree (BST)** is a binary tree where for any given node:<br>        - The left child’s value is **less than** the node’s value.<br>        - The right child’s value is **greater than** the node’s value.<br>2. **Postorder Traversal**:<br>    <br>    - A **postorder traversal** is an optimal approach for this problem. This allows us to traverse the tree from the leaves to the root, ensuring that when we check if a subtree is a BST, we already have information about its children.<br>3. **Tracking Information for Each Node**:<br>    <br>    - For each node, we need to keep track of:<br>        - **Size of the subtree** (number of nodes).<br>        - **Minimum value** in the subtree.<br>        - **Maximum value** in the subtree.<br>        - **Whether the subtree is a valid BST**.<br>4. **Dynamic Programming (Memoization)**:<br>    <br>    - We will store the results for each subtree so that we don't recompute the information for the same subtree multiple times.<br><br>---<br><br>### **Approach**:<br><br>1. Perform a **postorder traversal** of the tree (left-right-root).<br>2. For each node, check the following:<br>    - If the left and right subtrees are valid BSTs.<br>    - Ensure the current node’s value is greater than the maximum value of the left subtree and less than the minimum value of the right subtree.<br>3. If the current subtree is a valid BST:<br>    - Calculate its size (size of left + size of right + 1 for the current node).<br>    - Update the largest BST size if the current subtree’s size is greater.<br>4. Return the largest BST size found. |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Rotten Oranges<br>Min time to rot all oranges.<br>Every minute, if a Fresh Orange is adjacent to a Rotten Orange in 4-direction ( upward, downwards, right, and left ) it becomes Rotten.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | Key concept:<br><br>**Multi-Source BFS**:<br><br>- Start the BFS simultaneously from all rotten oranges (as multiple sources of infection).<br>- Use a queue to process all the rotten oranges at the same time, spreading the "rot" layer by layer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| Word ladder 1.<br><br>A **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord`                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | This problem is similar to transform word problem of DP. but there the allowed operations are add, replace, delete.  Here the allowed operations is only one -> - Only one letter can be changed at a time.<br>- Each transformed word must exist in the given `wordList`<br>. It will be solved via graph. <br><br>### Algorithm Steps<br><br>1. **Preprocess the `wordList`**:<br>    <br>    - Create a dictionary of patterns. Each key is a pattern, and the value is a list of words that match it.<br>    - Example: For `hot` and `dot`, the pattern dictionary is:<br>        <br>        json<br>        <br>        Copy code<br>        <br>        `{     "*ot": ["hot", "dot"],     "h*t": ["hot"],     "ho*": ["hot"],     "d*t": ["dot"],     "do*": ["dot"] }`<br>        <br>2. **Perform BFS**:<br>    <br>    - Start with the `beginWord` in the queue.<br>    - For each word, generate its possible patterns.<br>    - For each pattern, find all valid transformations (neighbors) from the pattern dictionary.<br>    - Mark visited words to avoid revisiting.<br>3. **Stop When `endWord` is Reached**:<br>    <br>    - Return the current level (number of transformations) when you dequeue `endWord`.<br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Number of Distinct Islands [dfs multisource]](https://takeuforward.org/data-structure/number-of-islands/)<br>The **Number of Distinct Islands** problem involves finding unique islands in a 2D grid where islands are represented as groups of connected `1`s (land), connected 4-directionally (up, down, left, right). Two islands are considered the same if they have the same shape, regardless of their positions.                                                                                                                                                                                                                                                                                                                                                               | The main challenge here is to identify the identical islands<br>How to do that?<br><br>Depth-First Search (DFS) with a multi-source approach, we need to identify and count unique shapes of islands in a 2D grid. Each island is represented by a group of connected `1`s (land)<br><br>Steps to Solve the Problem<br>	1.	Grid Representation: The grid consists of `0`s (water) and `1`s (land). An island is formed by connecting adjacent land cells (up, down, left, right).<br>	2.	DFS Traversal: Use DFS to explore each island. During the exploration, we will record the shape of the island.<br>	3.	Shape Representation: To uniquely represent the shape of each island, we can u**se a relative coordinate system**. As we traverse the island, we can store the coordinates of each cell relative to the starting point of the DFS for that island.<br>	4.	Hashing for Uniqueness: After traversing an island and collecting its shape representation, convert this representation into a hashable format (like a tuple or string) and store it in a set. Using a set ensures that only unique shapes are counted.<br><br>Hashing for Uniqueness<br>Once you have collected all relative positions for an island:<br>	1.	Normalize: Sort the list of tuples representing the shape. This step ensures that different starting points yield equivalent representations.<br>	2.	Convert to Hashable Type: Convert the sorted list into a tuple (or string) because lists are not hashable in Python.<br>	3.	Store in Set: Add this hashable representation to a set. Since sets automatically handle duplicates, only unique shapes will be stored.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Course Schedule - II](https://takeuforward.org/data-structure/course-schedule-i-and-ii-pre-requisite-tasks-topological-sort-g-24/)<br>Here we have to determine the possible sequence.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | This is a classic **topological sorting** problem in a **directed acyclic graph (DAG)**<br><br>**Algorithm Choices**:<br><br>- **Kahn’s Algorithm** (Iterative): Uses an in-degree array to track the number of incoming edges for each node.<br>- **DFS-based Topological Sort** (Recursive): Uses a stack to track the order and detects cycles using visited states.<br><br>### Solution: Kahn’s Algorithm (BFS-based)<br><br>1. **Step 1: Build the Graph and In-Degree Array**<br>    <br>    - Create an adjacency list to represent the graph.<br>    - Create an array to track the in-degree (number of prerequisites) for each course.<br>2. **Step 2: Initialize the Queue**<br>    <br>    - Add all nodes (courses) with `in-degree = 0` to a queue because they have no prerequisites.<br>3. **Step 3: Process the Graph**<br>    <br>    - Repeatedly remove nodes from the queue, add them to the result list, and decrease the in-degree of their neighbors.<br>    - If a neighbor’s in-degree becomes `0`, add it to the queue.<br>4. **Step 4: Check for Cycles**<br>    <br>    - If all nodes are processed, return the result list.<br>    - If there are nodes left unprocessed (in-degree > 0), a cycle exists, and it is impossible to complete all courses.<br><br>### Solution: DFS-based Topological Sort<br><br>1. **Step 1: Build the Graph**<br>    <br>    - Create an adjacency list to represent the graph.<br>2. **Step 2: Perform DFS**<br>    <br>    - Use a visited array to track the state of each node:<br>        - `0`: Not visited.<br>        - `1`: Visiting (currently in the stack, used to detect cycles).<br>        - `2`: Visited (processed).<br>    - Perform DFS and add nodes to a stack in post-order (after all their neighbors have been visited).<br>3. **Step 3: Check for Cycles**<br>    <br>    - If a cycle is detected during DFS (a node is revisited while in the "visiting" state), return an empty list.<br>4. **Step 4: Return the Result**<br>    <br>    - Reverse the stack to get the topological order.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|\|[Djisktra's Algorithm](https://takeuforward.org/data-structure/dijkstras-algorithm-using-set-g-33/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | **Logic**:<br><br>- Use a **priority queue (min-heap)** to always process the node with the smallest known distance.<br>- For each node, update the distances of its neighbors if a shorter path is found.<br>- Repeat until all nodes are processed.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Cheapest flights within k stops](https://takeuforward.org/data-structure/g-38-cheapest-flights-within-k-stops/)<br>There are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.<br><br>You are also given three integers `src`, `dst`, and `k`, return _**the cheapest price** from_ `src` _to_ `dst` _with at most_ `k` _stops._ If there is no such route, return `-1`.                                                                                                                                                                                                                                                  | **Shortest Path with Constraints**:<br><br>- Unlike Dijkstra's algorithm, which minimizes distance, this problem also imposes a constraint on the number of stops.<br><br>### **Algorithm**<br><br>We'll use a **priority queue (min-heap)** for efficient traversal:<br><br>1. **Step 1**: Build the graph using an adjacency list.<br>2. **Step 2**: Use a priority queue to store tuples of `(current_cost, current_node, stops)`.<br>3. **Step 3**: Perform BFS-like traversal:<br>    - For each node, explore its neighbors.<br>    - Update the cost and stops for each neighbor if it improves the current path.<br>    - Push the updated neighbor to the queue.<br>    - Stop processing if the number of stops exceeds `k`.<br>4. **Step 4**: Return the minimum cost to reach the destination within `k` stops. If unreachable, return `-1`.<br><br>### **Key Insights**<br><br>1. **Use BFS for Bounded Depth**:<br>    - The BFS-like approach ensures we explore paths within the `k` stop constraint efficiently.<br>2. **Priority Queue for Optimality**:<br>    - Min-heap prioritizes cheaper paths, allowing early termination for optimal results.<br>3. **Dynamic Relaxation**:<br>    - Avoid redundant calculations by tracking the minimum cost to each city for a given stop count.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Bellman Ford Algorithm](https://takeuforward.org/data-structure/bellman-ford-algorithm-g-41/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Find the shortest paths from a single source node to all other nodes in a graph, including graphs with **negative edge weights** (but no negative weight cycles).<br><br><br>### **Algorithm**<br><br>1. **Initialization**:<br>    <br>    - Set the distance to the source node as 000 and all other nodes to infinity (`inf`).<br>2. **Relax Edges** (Repeat n−1n-1n−1 times):<br>    <br>    - For every edge (u,v,weight)(u, v, weight)(u,v,weight), update: distance[v]=min⁡(distance[v],distance[u]+weight)\text{distance}[v] = \min(\text{distance}[v], \text{distance}[u] + \text{weight})distance[v]=min(distance[v],distance[u]+weight)<br>3. **Negative Cycle Check**:<br>    <br>    - Perform one more relaxation iteration. If any distance is reduced, the graph contains a negative weight cycle.<br>4. **Output**:<br>    <br>    - Shortest distances or indicate the presence of a negative weight cycle.<br><br>While more versatile, Bellman-Ford is less efficient for graphs without negative weights.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| \|\|[Floyd Warshal Algorithm](https://takeuforward.org/data-structure/floyd-warshall-algorithm-g-42/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Compute the shortest paths between **all pairs of nodes** in a graph, including graphs with **negative weights** (but no negative weight cycles).<br><br>### **Algorithm**<br><br>1. **Initialization**:<br>    <br>    - Set `dist[i][j] = weight[i][j]` for all edges (i,j)(i, j)(i,j).<br>    - Set `dist[i][i] = 0` for all iii.<br>    - Set `dist[i][j] = ∞` if no direct edge exists between iii and jjj.<br><br>**Iterative Update**:<br><br>- For each node k, update<br><br>        dist[i][j]=min(dist[i][j],dist[i][k]+dist[k][j])<br>Repeat this for all pairs of nodes i,ji, ji,j.<br><br>**Negative Cycle Detection**:<br><br>- If `dist[i][i] < 0` for any iii, a negative weight cycle exists.<br><br><br>**Not Suitable for Large Graphs**:<br><br>- Inefficient for large graphs due to O(V3)O(V^3)O(V3) time complexity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Kruskal's Algorithm](https://takeuforward.org/data-structure/kruskals-algorithm-minimum-spanning-tree-g-47/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Finds the **Minimum Spanning Tree (MST)** of a graph. The MST connects all vertices with the minimum possible total edge weight, without any cycles.<br><br>![[images/Screenshot 2024-12-08 at 11.09.10 PM.png]]<br>	It includes all vertices of the graph.<br>	•	It contains exactly  edges, where  is the number of vertices.<br>	•	It does not contain any cycles, making it acyclic.<br><br>### **Key Concepts**<br><br>1. **Greedy Approach**:<br>    <br>    - Always select the **smallest edge** that doesn't form a cycle with the already selected edges.<br>2. **Union-Find (Disjoint Set)**:<br>    <br>    - Used to efficiently detect cycles during the edge selection process.<br>    - Supports operations: `find` (to check if two nodes are connected) and `union` (to connect two components).<br>3. **Edge Sorting**:<br>    <br>    - The edges are sorted by weight, and the algorithm proceeds to add the edges one by one in increasing order.<br><br>### **Algorithm**<br><br>1. **Initialize**:<br>    <br>    - Sort all edges in **non-decreasing order** of their weight.<br>    - Initialize a **disjoint-set** to track the connected components of the graph.<br>2. **Process Edges**:<br>    <br>    - Iterate through the sorted edges and, for each edge (u,v)(u, v)(u,v):<br>        - If uuu and vvv belong to different components (detected using the `find` operation), add the edge to the MST and perform a `union` operation to merge the components.<br>3. **Stop**:<br>    <br>    - Stop when there are V−1V-1V−1 edges in the MST, where VVV is the number of vertices.<br>4. **Output**:<br>    <br>    - The MST is the set of edges added to the tree.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Accounts Merge](https://leetcode.com/problems/accounts-merge/)<br>Given a list of accounts, merge accounts that have the same email address. Each account is represented as a list, where the first element is the account holder's name, followed by the list of email addresses associated with the account.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | - **Initialize Data Structures**:<br>    <br>    - Create a mapping from emails to their corresponding accounts using a Union-Find structure.<br>- **Union Emails**:<br>    <br>    - For each account, union all the emails in the account to form connected components.<br>- **Group Emails**:<br>    <br>    - For each connected component, collect all emails, sort them, and associate them with the account holder's name.<br>- **Return Result**:<br>    <br>    - Return the merged accounts.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Bridges in Graph](https://takeuforward.org/graph/bridges-in-graph-using-tarjans-algorithm-of-time-in-and-low-time-g-55/)<br><br>Find **bridges** (or **critical edges**) in an undirected graph. A **bridge** is an edge that, if removed, would increase the number of connected components in the graph. In other words, removing it disconnects the graph.                                                                                                                                                                                                                                                                                                                                                                                                                           | ### **Key Concepts**<br><br>1. **DFS Traversal**:<br>    <br>    - Perform a **Depth-First Search (DFS)** on the graph and track the discovery and low times for each node.<br>    - **Discovery time**: The time when a node is first visited in DFS.<br>    - **Low time**: The lowest discovery time reachable from a node, considering back edges.<br>2. **Low Link Values**:<br>    <br>    - For a node u, the **low[u]** value is the smallest discovery time reachable from u, either directly or through descendants.<br>    - If for an edge (u,v), the condition `low[v] > discovery[u]` holds, then the edge (u,v) is a bridge.<br>3. **DFS Tree**:<br>    <br>    - Treat the graph as a DFS tree. Bridges are edges that connect a node to a subtree, but no back edge connects that subtree to an ancestor.<br><br>### **Algorithm (Tarjan’s Algorithm for Bridges)**<br><br>1. **Initialization**:<br>    <br>    - Create arrays `discovery[]`, `low[]`, and `parent[]` to store discovery time, low time, and parent of each node.<br>    - Start DFS from any unvisited node and track discovery/low times.<br>2. **DFS Traversal**:<br>    <br>    - For each node, visit its adjacent nodes.<br>    - If the adjacent node is unvisited, recurse and update the `low` value of the current node based on the `low` value of the child.<br>    - If `low[v] > discovery[u]`, the edge (u,v)(u, v)(u,v) is a bridge.<br>3. **Output**:<br>    <br>    - Collect and return all edges that are bridges.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| **Dynamic programming**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Maximum sum of non-adjacent elements (DP 5)](https://takeuforward.org/data-structure/maximum-sum-of-non-adjacent-elements-dp-5/)\|<br>Find the maximum sum of elements from an array such that no two selected elements are adjacent.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Use DP to decide whether to **include** or **exclude** the current element while ensuring no adjacent elements are picked.<br><br>dp[i]=max(arr[i]+dp[i-2],dp[i-1])                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Ninja's Training (DP 7)](https://takeuforward.org/data-structure/dynamic-programming-ninjas-training-dp-7/)<br>A ninja can perform one of three activities each day, each with a different score. The ninja cannot perform the same activity on consecutive days. Find the maximum score the ninja can achieve over nnn days.                                                                                                                                                                                                                                                                                                                                                                                                                                                           | Define a DP table where `dp[i][j]` represents the maximum score obtainable on day iii, if the ninja performs activity jjj on that day.<br><br><code> dp[i][j]=max(dp[i-1][k]+points[i][j]) </code><br><br>For each activity j on day i, choose the maximum possible score from the other activities k on the previous day.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Minimum path sum in Grid (DP 10)](https://takeuforward.org/data-structure/minimum-path-sum-in-a-grid-dp-10/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Use the fact that you can only arrive at (i,j) from either (i−1,j) (above) or (i,j−1 (left).<br><br>**State Transition**:<br><code><br>- dp[i][j]=grid[i][j]+min(dp[i-1][j],dp[i][j-1])<br></code>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Subset sum equal to target (DP- 14)](https://takeuforward.org/data-structure/subset-sum-equal-to-target-dp-14/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Use a DP table where `dp[i][j]` is `True` if a subset of the first iii elements has a sum equal to j.<br>**State Transition**:<br><br>If the current element is **not included**: `dp[i][j] = dp[i-1][j]`<br>If the current element is **included**: `dp[i][j] = dp[i-1][j - arr[i-1]]` (provided j≥arr[i-1]).<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Assign Cookies](https://takeuforward.org/interview-sheets/strivers-79-last-moment-dsa-sheet-ace-interviews)<br>Given two arrays, `g` (children's greed factors) and `s` (cookie sizes), determine the maximum number of children that can be satisfied. A child can be satisfied only if they receive a cookie with a size greater than or equal to their greed factor.                                                                                                                                                                                                                                                                                                                                                                                                                 | Greedy<br>### **Approach**:<br><br>1. Sort both `g` and `s` in ascending order.<br>2. Use two pointers:<br>    - One for `g` (children) and one for `s` (cookies).<br>3. Try to satisfy the smallest greed factor with the smallest available cookie.<br>4. Increment the count whenever a child is satisfied and move both pointers; otherwise, move the cookie pointer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| *DP version of Assign cookies problem*<br>**Maximum Contentment with Limited Cookies**<br>Each child has a greed factor, and each cookie has a size. You must maximize the total contentment score of the children, where the contentment score is the size of the cookie assigned to a child minus their greed factor (if the cookie satisfies them). Each cookie can be used only once.                                                                                                                                                                                                                                                                                                                                                                                                | **DP**: Necessary when there are additional constraints (e.g., limited cookies, maximizing satisfaction scores) or overlapping subproblems requiring optimization over multiple decisions.<br><br>**Approach**:<br><br>- Use DP to track the maximum contentment score.<br>- Define `dp[i][j]` as the maximum contentment score for the first i children and j cookies.<br>Transition:<br>If the ith child is not assigned a cookie <code>dp[i][j]=dp[i-1][j]</code><br>if the ith child is assigned the kth cookie <code>dp[i][j]=max(dp[i-1][j-1]+s[k]-g[i], dp[i-1][j] , where s[k]>g[i] ) </code><br><br><br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
| [Rod Cutting Problem \| (DP - 24)](https://takeuforward.org/data-structure/rod-cutting-problem-dp-24/)<br>We are given a rod of size ‘N’. It can be cut into pieces. Each length of a piece has a particular price given by the price array. Our task is to find the maximum revenue that can be generated by selling the rod after cutting( if required) into pieces.<br>we can also have multiple cuts of same size.                                                                                                                                                                                                                                                                                                                                                                   | problem is similar to the **unbounded knapsack problem** where:<br><br>- The rod length is the capacity.<br>- Each cut has a "weight" (length) and a "value" (price).<br><br>**Choices**:<br><br>- For a rod of length nnn, decide whether to cut a piece of size i+1i+1i+1 or skip that piece.<br>- Transition: Maximize the value by either including or excluding the cut<br><br>**State Transition**:<br><br>- Define `dp[j]` as the maximum price obtainable for a rod of length j.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                             |                   |            |                 |
