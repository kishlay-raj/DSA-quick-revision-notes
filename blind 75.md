
| Question                                                                                                                                                                                                                                                                                                                  | Hint to remember                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Coding hint                                                                                                                                                                                                                                                                                                    | Misktake to avoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Not solved     | Revision needed |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | --------------- |
| <br>\|[2Sum Problem](https://takeuforward.org/data-structure/two-sum-check-if-a-pair-with-given-sum-exists-in-array/)\|                                                                                                                                                                                                   | use a hash map to store the difference between the target and each element as you iterate through the array. Check if the current element exists in the map; if so, you've found the pair that sums to the target.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Best Time to Buy and Sell Stock \|(DP-35)](https://takeuforward.org/data-structure/stock-buy-and-sell-dp-35/)\|<br>We can buy and sell only once                                                                                                                                     | maintain two arrays:<br><br>1. **Left Min Array:** Track the minimum price up to each day.<br>2. **Right Max Profit Array:** Track the maximum profit achievable if you sold on each day.<br><br>At the end, compute the maximum difference between prices by comparing the current price and the minimum from the left array. This approach mimics the logic of DP by reusing precomputed values to optimize the solution.                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| [Contains Duplicate](https://takeuforward.org/data-structure/contains-duplicate-check-if-a-value-appears-atleast-twice/)                                                                                                                                                                                                  | use hashset                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| Product of Array Except Self<br>eg.<br>**Input:** N = 5, array[] = {1,2,3,4,5}<br>**Output**: 120 60 40 30 24                                                                                                                                                                                                             | use two passes: in the first pass, calculate the running product of all elements to the left of each index, and in the second pass, calculate the running product of elements to the right while multiplying it with the left product from the first pass.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| [Kadane's Algorithm, maximum subarray sum](https://takeuforward.org/data-structure/kadanes-algorithm-maximum-subarray-sum-in-an-array/)                                                                                                                                                                                   | maintaining a running sum of the current subarray, resetting it to the current element if the sum becomes negative. The maximum subarray sum is updated whenever the current running sum exceeds the previously recorded maximum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| [Find minimum in Rotated Sorted Array](https://takeuforward.org/data-structure/minimum-in-rotated-sorted-array/)                                                                                                                                                                                                          | To solve the "Find Minimum in Rotated Sorted Array" problem, use binary search by comparing the middle element with the rightmost element. If the middle element is greater than the rightmost, the minimum lies in the right half; otherwise, it lies in the left half, narrowing down until the minimum is found.                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| [Search in Rotated Sorted Array I](https://takeuforward.org/data-structure/search-element-in-a-rotated-sorted-array/)                                                                                                                                                                                                     | 1. **Identify the sorted half:** In each iteration, compare the middle element with the left and right bounds to determine which half of the array is sorted.<br>    <br>    - If the left half is sorted, check if the target lies within the range of the left half (i.e., between the left and mid elements).<br>    - If the right half is sorted, check if the target lies within the range of the right half (i.e., between the mid and right elements).<br>2. **Adjust the search range:** Based on the sorted half and the target’s value, discard the irrelevant half and continue the binary search on the remaining half.<br>    <br><br>Repeat this process until the target is found or the search space is exhausted. |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| [3 sum](https://takeuforward.org/data-structure/3-sum-find-triplets-that-add-up-to-a-zero/)                                                                                                                                                                                                                               | To solve the 3 Sum problem, first sort the array and then use a two-pointer approach: for each element, treat it as a fixed element and use two pointers (one starting right after the fixed element and the other from the end of the array) to find two other numbers that sum to the target (negative of the fixed element). Adjust the pointers based on the sum, and skip duplicates to avoid repeated triplets.[[3 sum]]<br>                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| Container with most water                                                                                                                                                                                                                                                                                                 | Use two pointers, one at the beginning and one at the end of the array. Calculate the area between the two pointers, move the pointer with the smaller height inward, and repeat until the pointers meet to maximize the container area.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | not solved yet |                 |
| <br>Binary<br>                                                                                                                                                                                                                                                                                                            | Learn how to shift bits to create or reduce a number. <br>create notes on standard operations                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| Sum of Two Integers                                                                                                                                                                                                                                                                                                       | - Use XOR (`^`) to add the bits of `a` and `b` without considering the carry.<br>- Use AND (`&`) to calculate the carry, then shift it left by 1 (`<< 1`).<br>- Repeat the process until the carry becomes 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | def getSum(a, b):<br>    while b != 0:<br>        carry = a & b         # Calculate carry<br>        a = a ^ b             # Sum without carry<br>        b = carry << 1        # Shift carry left<br>    return a<br><br># Example usage:<br>result = getSum(3, 5)  # Output will be 8<br>print(result)<br>   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | No solved yet  |                 |
| [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)                                                                                                                                                                                                                                                       | To solve the **Number of 1 Bits** problem, repeatedly check the least significant bit of the number using `n & 1`, then right-shift the number by one bit (`n >> 1`) to check the next bit. Count how many times the result is 1 until the number becomes 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | def hammingWeight(n):<br>    count = 0<br>    while n:<br>        count += n & 1  # Check if the least significant bit is 1<br>        n >>= 1         # Right shift to check the next bit<br>    return count<br><br><br>                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | not solved yet |                 |
| [Counting Bits](https://leetcode.com/problems/counting-bits/)                                                                                                                                                                                                                                                             | you count the number of 1s in the binary representation for each number from 0 to `n`,[[Counting Bits]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | not solved yet |                 |
| [Missing Number](https://leetcode.com/problems/missing-number/)<br>Find the only missing number between 0-n from array                                                                                                                                                                                                    | Use the formula for the sum of the first `n` numbers: `sum = n * (n + 1) / 2`. Subtract the sum of the array elements from this expected sum to find the missing number.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | not solved yet |                 |
| [Reverse Bits](https://leetcode.com/problems/reverse-bits/)                                                                                                                                                                                                                                                               | To solve the **Reverse Bits** problem, iterate over all 32 bits of the number, extract each bit using bitwise operations, and shift it into the reversed position in a result variable. Shift the result left to make space for the next bit, and shift the input number right to process the next bit.[[reverseBits]]                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | not solved yet |                 |
| Graph                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| [Clone Graph](https://leetcode.com/problems/clone-graph/)                                                                                                                                                                                                                                                                 | To solve the **Clone Graph** problem, use a breadth-first search (BFS) or depth-first search (DFS) to traverse the graph. As you visit each node, create a clone of that node and map it to the original node. Then, for each neighbor of the original node, ensure you clone it if it hasn't been cloned yet, and connect the cloned nodes accordingly.                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                | make sure that you track the visited node                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                |                 |
| [Course Schedule](https://leetcode.com/problems/course-schedule/)<br>You must take course B before you take course A. Return true if u can finish all courses.                                                                                                                                                            | Basically we have to find if the graph is **cyclic** <br>Use **topological sorting** or **DFS cycle detection**:<br><br>- For **topological sorting**, try to track courses with no prerequisites (in-degree 0) and process them first.<br>- For **DFS**, try marking courses as being visited, and if you revisit a course that’s still being processed, you found a cycle.[[course schedule]]<br><br>                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | not solved     |                 |
| [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)<br>Find coordinates from where water can flow to both Pacific and Atlantic ocean [[pacific Atlantic water flow]]<br>                                                                                                            | You need to simulate water flowing **from the oceans** rather than trying to track water flow to the oceans.Think of starting at the edges (where the oceans touch the grid), and figure out which cells can reach both the **Pacific** and **Atlantic** by using Depth First Search (DFS) or Breadth First Search (BFS)                                                                                                                                                                                                                                                                                                                                                                                                            | **Key observation**: For water to flow from one cell to another, the destination cell must be **equal or lower in height** than the current cell.<br><br>Start loop from all 4 corners and mark the ones which are reachable from Atlantic and Pacific.<br><br>Common ones present in both will be the answer. |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| [Number of Islands](https://leetcode.com/problems/number-of-islands/)<br>In a matrix containing 0s &1s, find the number of islands                                                                                                                                                                                        | The problem can be reduced to finding the number of **connected components** in this graph<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)<br>Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._<br><br>You must write an algorithm that runs in `O(n)` time.<br>**We have to solve it regardless of order.** | - First, we will put all the array elements into the set data structure.<br>- If a number, num, is a starting number, ideally, num-1 should not exist. So, for every element, x, in the set, we will check if x-1 exists inside the set. :<br>    - **If x-1 exists:** This means x cannot be a starting number and we will move on to the next element in the set.<br>    - **If x-1 does not exist:** This means x is a starting number of a sequence. So, for number, x, we will start finding the consecutive elements.                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                | mistake to avoid:<br><br>- Treating duplicates as separate nodes in the graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                 |
| [Alien dictionary](https://takeuforward.org/data-structure/alien-dictionary-topological-sort-g-26/)<br>Given a sorted dictionary of an alien language having N words and k starting alphabets of a standard dictionary. Find the order of characters in the alien language.                                               | The problem can be reduced to **topological sorting** of a directed acyclic graph (DAG)<br><br>Comparing each pair of consecutive words in the dictionary, we can construct a directed graph like the following:<br><br>How to build the graph?<br>For each pair of adjacent words, compare characters until you find the first mismatch. This mismatch indicates the order of the characters<br><br>                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                | 1. **Not Handling the Prefix Case Correctly**<br><br>**Mistake**: Failing to handle the case where one word is a prefix of another word. For example, in the input `["abc", "ab"]`, `"abc"` appears before `"ab"`, which is invalid because `"ab"` should come first in lexicographical order.<br><br>**How to Avoid**: If `word2` is a **prefix** of `word1`, and `word1` is longer than `word2`, the input dictionary is invalid. You need to detect this case and return an empty result.<br><br>if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:<br>    return ""  # Invalid case: no valid order<br><br>Mistake 2:<br>**Not Detecting Cycles in the Graph** |                |                 |
| Graph Valid Tree<br>The **Graph Valid Tree** problem asks you to determine if a given graph is a **valid tree**. A tree is an **undirected, connected graph** with **no cycles** and exactly **n-1 edges** where `n` is the number of nodes.                                                                              | To solve the **Graph Valid Tree** problem:<br><br>1. First, check if the number of edges is exactly `n-1` (a necessary condition for a tree).<br>2. Use **DFS/BFS** to ensure the graph is **connected** and detect any **cycles**.<br>3. Finally, verify that all nodes have been visited to ensure full connectivity.                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
| https://takeuforward.org/graph/connected-components-in-graphs/<br>requires identifying distinct **subgraphs** within a graph                                                                                                                                                                                              | use **DFS** or **BFS** to explore the graph, marking visited nodes. Start a new traversal for each unvisited node, and count how many times you initiate a new traversal to get the number of connected components.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                |                 |
