
| Question                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Hint to remember                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Coding hint                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Misktake to avoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Not solved     | Revision needed        |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------------- |
| <br>\|[2Sum Problem](https://takeuforward.org/data-structure/two-sum-check-if-a-pair-with-given-sum-exists-in-array/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | use a hash map to store the difference between the target and each element as you iterate through the array. Check if the current element exists in the map; if so, you've found the pair that sums to the target.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Best Time to Buy and Sell Stock \|(DP-35)](https://takeuforward.org/data-structure/stock-buy-and-sell-dp-35/)\|<br>We can buy and sell only once                                                                                                                                                                                                                                                                                                                                                                                                             | maintain two arrays:<br><br>1. **Left Min Array:** Track the minimum price up to each day.<br>2. **Right Max Profit Array:** Track the maximum profit achievable if you sold on each day.<br><br>At the end, compute the maximum difference between prices by comparing the current price and the minimum from the left array. This approach mimics the logic of DP by reusing precomputed values to optimize the solution.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Contains Duplicate](https://takeuforward.org/data-structure/contains-duplicate-check-if-a-value-appears-atleast-twice/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | use hashset                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Product of Array Except Self<br>eg.<br>**Input:** N = 5, array[] = {1,2,3,4,5}<br>**Output**: 120 60 40 30 24                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | use two passes: in the first pass, calculate the running product of all elements to the left of each index, and in the second pass, calculate the running product of elements to the right while multiplying it with the left product from the first pass.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Kadane's Algorithm, maximum subarray sum](https://takeuforward.org/data-structure/kadanes-algorithm-maximum-subarray-sum-in-an-array/)                                                                                                                                                                                                                                                                                                                                                                                                                                                           | maintaining a running sum of the current subarray, resetting it to the current element if the sum becomes negative. The maximum subarray sum is updated whenever the current running sum exceeds the previously recorded maximum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Find minimum in Rotated Sorted Array](https://takeuforward.org/data-structure/minimum-in-rotated-sorted-array/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | To solve the "Find Minimum in Rotated Sorted Array" problem, use binary search by comparing the middle element with the rightmost element. If the middle element is greater than the rightmost, the minimum lies in the right half; otherwise, it lies in the left half, narrowing down until the minimum is found.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Search in Rotated Sorted Array I](https://takeuforward.org/data-structure/search-element-in-a-rotated-sorted-array/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 1. **Identify the sorted half:** In each iteration, compare the middle element with the left and right bounds to determine which half of the array is sorted. **Identifying will help us identify and then trying to find the target there will help us select the correct half of binary search.**<br>    <br>    - If the left half is sorted, check if the target lies within the range of the left half (i.e., between the left and mid elements).<br>    - If the right half is sorted, check if the target lies within the range of the right half (i.e., between the mid and right elements).<br>2. **Adjust the search range:** Based on the sorted half and the target’s value, discard the irrelevant half and continue the binary search on the remaining half.<br>    <br><br>Repeat this process until the target is found or the search space is exhausted.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [3 sum](https://takeuforward.org/data-structure/3-sum-find-triplets-that-add-up-to-a-zero/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | To solve the 3 Sum problem, first sort the array and then use a two-pointer approach: for each element, treat it as a fixed element and use two pointers (one starting right after the fixed element and the other from the end of the array) to find two other numbers that sum to the target (negative of the fixed element). Adjust the pointers based on the sum, and skip duplicates to avoid repeated triplets.[[3 sum]]<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Container with most water                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Use two pointers, one at the beginning and one at the end of the array. Calculate the area between the two pointers, move the pointer with the smaller height inward, and repeat until the pointers meet to maximize the container area.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| <br>Binary<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Learn how to shift bits to create or reduce a number. <br>create notes on standard operations                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Sum of Two Integers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | - Use XOR (`^`) to add the bits of `a` and `b` without considering the carry.<br>- Use AND (`&`) to calculate the carry, then shift it left by 1 (`<< 1`).<br>- Repeat the process until the carry becomes 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | def getSum(a, b):<br>    while b != 0:<br>        carry = a & b         # Calculate carry<br>        a = a ^ b             # Sum without carry<br>        b = carry << 1        # Shift carry left<br>    return a<br><br># Example usage:<br>result = getSum(3, 5)  # Output will be 8<br>print(result)<br>                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | No solved yet  |                        |
| [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | To solve the **Number of 1 Bits** problem, repeatedly check the least significant bit of the number using `n & 1`, then right-shift the number by one bit (`n >> 1`) to check the next bit. Count how many times the result is 1 until the number becomes 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | def hammingWeight(n):<br>    count = 0<br>    while n:<br>        count += n & 1  # Check if the least significant bit is 1<br>        n >>= 1         # Right shift to check the next bit<br>    return count<br><br><br>                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| [Counting Bits](https://leetcode.com/problems/counting-bits/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | you count the number of 1s in the binary representation for each number from 0 to `n`,[[Counting Bits]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| [Missing Number](https://leetcode.com/problems/missing-number/)<br>Find the only missing number between 0-n from array                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Use the formula for the sum of the first `n` numbers: `sum = n * (n + 1) / 2`. Subtract the sum of the array elements from this expected sum to find the missing number.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| [Reverse Bits](https://leetcode.com/problems/reverse-bits/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | To solve the **Reverse Bits** problem, iterate over all 32 bits of the number, extract each bit using bitwise operations, and shift it into the reversed position in a result variable. Shift the result left to make space for the next bit, and shift the input number right to process the next bit.[[reverseBits]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| Graph                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Clone Graph](https://leetcode.com/problems/clone-graph/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | To solve the **Clone Graph** problem, use a breadth-first search (BFS) or depth-first search (DFS) to traverse the graph. As you visit each node, create a clone of that node and map it to the original node. Then, for each neighbor of the original node, ensure you clone it if it hasn't been cloned yet, and connect the cloned nodes accordingly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | make sure that you track the visited node                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                |                        |
| [Course Schedule](https://leetcode.com/problems/course-schedule/)<br>You must take course B before you take course A. Return true if u can finish all courses.                                                                                                                                                                                                                                                                                                                                                                                                                                    | Basically we have to find if the graph is **cyclic** <br>Use **topological sorting** or **DFS cycle detection**:<br><br>- For **topological sorting**, try to track courses with no prerequisites (in-degree 0) and process them first.<br>- For **DFS**, try marking courses as being visited, and if you revisit a course that’s still being processed, you found a cycle.[[course schedule]]<br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved     |                        |
| [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)<br>Find coordinates from where water can flow to both Pacific and Atlantic ocean [[pacific Atlantic water flow]]<br>                                                                                                                                                                                                                                                                                                                                                                                    | You need to simulate water flowing **from the oceans** rather than trying to track water flow to the oceans.Think of starting at the edges (where the oceans touch the grid), and figure out which cells can reach both the **Pacific** and **Atlantic** by using Depth First Search (DFS) or Breadth First Search (BFS)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | **Key observation**: For water to flow from one cell to another, the destination cell must be **equal or lower in height** than the current cell.<br><br>Start loop from all 4 corners and mark the ones which are reachable from Atlantic and Pacific.<br><br>Common ones present in both will be the answer.                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Number of Islands](https://leetcode.com/problems/number-of-islands/)<br>In a matrix containing 0s &1s, find the number of islands                                                                                                                                                                                                                                                                                                                                                                                                                                                                | The problem can be reduced to finding the number of **connected components** in this graph<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)<br>Given an unsorted array of integers `nums`, return _the length of the longest consecutive elements sequence._<br><br>You must write an algorithm that runs in `O(n)` time.<br>**We have to solve it regardless of order.**                                                                                                                                                                                                                                                                         | - First, we will put all the array elements into the set data structure.<br>- If a number, num, is a starting number, ideally, num-1 should not exist. So, for every element, x, in the set, we will check if x-1 exists inside the set. :<br>    - **If x-1 exists:** This means x cannot be a starting number and we will move on to the next element in the set.<br>    - **If x-1 does not exist:** This means x is a starting number of a sequence. So, for number, x, we will start finding the consecutive elements.<br><br>=====<br><br>To solve using graph<br>- Treat each number as a **node**.<br>- Create an edge between nodes if their values differ by 1.<br>- Use a **graph traversal** (like DFS or BFS) to find the size of each connected component.<br>- Track the largest connected component size as the answer.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | mistake to avoid:<br><br>- Treating duplicates as separate nodes in the graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                |                        |
| [Alien dictionary](https://takeuforward.org/data-structure/alien-dictionary-topological-sort-g-26/)<br>Given a sorted dictionary of an alien language having N words and k starting alphabets of a standard dictionary. Find the order of characters in the alien language.                                                                                                                                                                                                                                                                                                                       | The problem can be reduced to **topological sorting** of a directed acyclic graph (DAG)<br><br>Comparing each pair of consecutive words in the dictionary, we can construct a directed graph like the following:<br><br>How to build the graph?<br>For each pair of adjacent words, compare characters until you find the first mismatch. This mismatch indicates the order of the characters<br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | 1. **Not Handling the Prefix Case Correctly**<br><br>**Mistake**: Failing to handle the case where one word is a prefix of another word. For example, in the input `["abc", "ab"]`, `"abc"` appears before `"ab"`, which is invalid because `"ab"` should come first in lexicographical order.<br><br>**How to Avoid**: If `word2` is a **prefix** of `word1`, and `word1` is longer than `word2`, the input dictionary is invalid. You need to detect this case and return an empty result.<br><br>if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:<br>    return ""  # Invalid case: no valid order<br><br>Mistake 2:<br>**Not Detecting Cycles in the Graph**                                                                                                                                                                                                                                                                                                  |                |                        |
| Graph Valid Tree<br>The **Graph Valid Tree** problem asks you to determine if a given graph is a **valid tree**. A tree is an **undirected, connected graph** with **no cycles** and exactly **n-1 edges** where `n` is the number of nodes.                                                                                                                                                                                                                                                                                                                                                      | To solve the **Graph Valid Tree** problem:<br><br>1. First, check if the number of edges is exactly `n-1` (a necessary condition for a tree).<br>2. Use **DFS/BFS** to ensure the graph is **connected** and detect any **cycles**.<br>3. Finally, verify that all nodes have been visited to ensure full connectivity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| https://takeuforward.org/graph/connected-components-in-graphs/<br>requires identifying distinct **subgraphs** within a graph                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | use **DFS** or **BFS** to explore the graph, marking visited nodes. Start a new traversal for each unvisited node, and count how many times you initiate a new traversal to get the number of connected components.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Tree                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Height of a Binary Tree](https://takeuforward.org/data-structure/maximum-depth-of-a-binary-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | The **recursive DFS approach** is optimal for finding the height of a tree,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | def find_height(node):<br>    if node is None:<br>        return -1  # For 0-based height, or return 0 for height in terms of number of nodes<br>    left_height = find_height(node.left)<br>    right_height = find_height(node.right)<br>    return max(left_height, right_height) + 1<br>                                                                                                                                                                                                                                              | In recursive approaches, ensure you return `-1` for null nodes (for 0-based height) or `0` (for node-count based height) in the base case, depending on how height is defined in your problem.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                | try to solve using BFS |
| [Check if two trees are identical or not](https://takeuforward.org/data-structure/check-if-two-trees-are-identical/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | To check if two trees are identical, compare the root values and recursively check if both the left and right subtrees are identical. The trees are identical if both are empty or if their structures and node values match exactly at each level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | def are_identical(tree1, tree2):<br>    if tree1 is None and tree2 is None:<br>        return True<br>    if tree1 is not None and tree2 is not None:<br>        return (tree1.value == tree2.value and <br>                are_identical(tree1.left, tree2.left) and <br>                are_identical(tree1.right, tree2.right))<br>    return False<br>                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| <br>\|[Invert/Flip Binary Tree (Create)](https://takeuforward.org/data-structure/check-for-symmetrical-binary-tree/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | To invert or flip a binary tree, recursively swap the left and right child of each node. Traverse the tree and for each node, invert its left and right subtrees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | def invert_tree(node):<br>    if node:<br>        node.left, node.right = invert_tree(node.right), invert_tree(node.left)<br>    return node<br>                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Find Symmetric trees                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | To check if two trees are symmetric, recursively compare them to see if one tree is the mirror image of the other. The trees are symmetric if the left subtree of one tree matches the right subtree of the other and vice versa.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | def are_symmetric(tree1, tree2):<br>    if tree1 is None and tree2 is None:<br>        return True<br>    if tree1 and tree2:<br>        return (tree1.value == tree2.value and <br>                are_symmetric(tree1.left, tree2.right) and <br>                are_symmetric(tree1.right, tree2.left))<br>    return False<br>                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Maximum path sum](https://takeuforward.org/data-structure/maximum-sum-path-in-binary-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | To solve the **Maximum Path Sum** in a binary tree, you need to find the maximum sum of node values in any path, where the path can start and end at any node. The solution involves a recursive DFS approach to calculate the maximum path sum passing through each node and keeping track of the global maximum.<br><br>### Key Steps:<br><br>1. For each node, compute the maximum sum of a path that includes the node and one of its subtrees (left or right).<br>2. Update the global maximum with the sum of the node's value and the maximum sums from both left and right subtrees (if applicable).<br>3. Return the maximum sum for each subtree path to its parent (only one subtree can be included in the return path).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | def max_path_sum(node):<br>    def helper(node):<br>        if not node:<br>            return 0<br>        left = max(helper(node.left), 0)  # ignore negative paths<br>        right = max(helper(node.right), 0)<br>        local_max = node.value + left + right  # max path through this node<br>        global_max[0] = max(global_max[0], local_max)<br>        return node.value + max(left, right)  # return max single path upwards<br><br>    global_max = [-float('inf')]<br>    helper(node)<br>    return global_max[0]<br> | - **Not Handling Negative Values**: Ensure that you correctly handle paths with negative sums by ignoring them when calculating maximum paths. Use `max(helper(node.left), 0)` to avoid adding negative contributions.<br><br>**Misunderstanding Path Definition**: Remember that the path can start and end at any node, and it can include both subtrees of a node. Don't limit your calculations to just left or right subtrees; consider paths that pass through the current node.<br><br>- **Incorrectly Updating Global Maximum**: Ensure that you update the global maximum path sum every time you compute a new local maximum path that passes through the current node, which includes contributions from both left and right subtrees.<br>    <br>- **Returning Incorrect Values**: When returning from the recursive function, only return the maximum sum of the path that can be extended to the parent node, not the total maximum path that includes both subtrees. |                | imp to revise          |
| [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)<br>Given the `root` of a binary tree, return _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between                                                                                                                                                                                                                                                                                  | perform a level-order traversal using a queue while keeping track of the current direction (left to right or right to left). By alternating the direction with each level, I can easily collect the node values in the desired order.<br><br>Note: The way we traverse the node of a level is ALWAYS from left to right. Only when these nodes are inserted into the final result list are they reversed. We can alternatively keep changing the value of the boolean value to reverse every alternate levels.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| \|[Serialize and deserialize Binary Tree](https://takeuforward.org/data-structure/serialize-and-deserialize-a-binary-tree/)\|<br><br>imp: watch video solution <br>https://youtu.be/-YbXySKJsX8                                                                                                                                                                                                                                                                                                                                                                                                   | **Step 1:** Check if the tree is empty: If the root is null, return an empty string.<br><br>**Step 2:** Initialise an empty string: This string will store the serialised binary tree.<br><br>**Step 3:** Use a queue for level-order traversal: Initialise a queue and enqueue the root.<br><br>![](https://static.takeuforward.org/content/serialise-deserialise-image5-rCwIAtKs)<br><br>**Step 4:** Within the level-order traversal loop:<br><br>1. Dequeue a node from the queue.<br>2. If the node is null, append "#" to the string.<br>3. If the node is not null, append its data value along with a ‘,’ (comma) to the string. This comma acts as a delimiter that separates the different node values in the string. Enqueue its left and right children.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | ![[images/Pasted image 20241020223148.png]]<br><br>imp watch this video https://youtu.be/-YbXySKJsX8                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Subtree of Another Tree](https://takeuforward.org/data-structure/subtree-of-another-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | - Traverse the main tree to find nodes that match the root of the subtree.<br>- Once a potential match is found, recursively compare both the left and right children of the nodes in the main tree and subtree.<br>- Return true if an identical subtree structure is found, otherwise continue searching in the left or right subtrees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| <br>\|\|[Construct the Binary Tree from Postorder and Inorder Traversal](https://takeuforward.org/data-structure/construct-binary-tree-from-inorder-and-postorder-traversal/)\|                                                                                                                                                                                                                                                                                                                                                                                                                   | ### Key Concepts:<br><br>1. **Inorder Traversal**:<br>    <br>    - Nodes are visited in the order: _Left Subtree → Root → Right Subtree_.<br>2. **Postorder Traversal**:<br>    <br>    - Nodes are visited in the order: _Left Subtree → Right Subtree → Root_.<br>    - The last element in the postorder array is always the root of the current subtree.<br><br>### Approach to Solve the Problem:<br><br>#### 1. Root Identification:<br><br>- The last element of the postorder traversal is the root of the tree or subtree.<br><br>#### 2. Divide Inorder Array:<br><br>- Find the index of the root in the inorder traversal.<br>- The elements to the left of the root in the inorder array represent the left subtree.<br>- The elements to the right represent the right subtree.<br><br>#### 3. Recursive Construction:<br><br>- Recursively repeat the process for the left and right subtrees using appropriate slices of the inorder and postorder arrays.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Check if a tree is a BST or BT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | - A binary search tree (BST) follows the property where for each node, the left subtree contains values smaller than the node and the right subtree contains values larger.<br>- Perform an in-order traversal and check if the nodes are visited in strictly increasing order.<br>- If any node violates the order during traversal, the tree is not a BST.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Find K-th smallest element in BST](https://takeuforward.org/data-structure/kth-largest-smallest-element-in-binary-search-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | - Perform an in-order traversal of the BST, as it visits nodes in ascending order.<br>- Keep a counter during the traversal and stop when the counter reaches `k`.<br>- The node at that point will be the `k`th smallest element in the BST.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Find kth largest element in BST                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | - Perform a reverse in-order traversal (right, root, left) on the BST to visit nodes in descending order.<br>- Keep a counter and stop the traversal once it reaches `k`.<br>- The node at that point will be the `k`th largest element in the BST.<br><br>or <br>**Augmented Tree with Node Counts**: Modify each node in the BST to store the count of nodes in its left and right subtrees. Using this information, you can determine the kkkth largest by navigating directly, based on the counts, without a full traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Find LCA of two nodes in BST                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | - Start at the root and compare the values of the two nodes with the current node.<br>- If both nodes are smaller than the current node, move to the left child; if both are larger, move to the right child.<br>- The first node where one value is smaller and the other is larger (or one matches the current node) is the Lowest Common Ancestor (LCA).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Implement Trie (Prefix Tree)](https://takeuforward.org/data-structure/implement-trie-1/)<br><br>1. insert<br>2. Search<br>3. Start with                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 1. **`insert(String word)`**:<br>    <br>    - Converts each character to an index (`ch - 'a'`) and adds nodes to the Trie if they don’t exist at each level.<br>    - Marks the end of the word when the word is fully inserted.<br>2. **`search(String word)`**:<br>    <br>    - Checks each character in the word to see if the path exists in the Trie.<br>    - Returns `true` if all characters are found and the last node is marked as the end of a word.<br>3. **`startsWith(String prefix)`**:<br>    <br>    - Similar to `search`, but it doesn’t check `isEndOfWord`, only confirming if the path for the prefix exists.<br><br>Detail:[[Trie - Search, insert, Prefix]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Implement Trie - 2 (Prefix Tree)](https://takeuforward.org/data-structure/implement-trie-ii/)<br>1. Insert<br>2. Count words equal to word: Return the count of occurrences of the string <br>3. count words starting with Prefix<br>4. Erase: Delete one occurrence of the string                                                                                                                                                                                                                                                                                                               | To solve this, we’ll use an enhanced Trie structure where each `TrieNode` keeps track of:<br><br>- How many times words pass through that node (`prefixCount`).<br>- How many times that node marks the end of a word (`wordCount`).<br><br>### Explanation of Each Operation<br><br>1. **Insert (word)**:<br>    <br>    - For each character in `word`, navigate through the Trie, creating nodes if they don’t exist.<br>    - Increment `prefixCount` at each node to indicate a word passes through it.<br>    - When reaching the end of `word`, mark the end node and increment its `wordCount`.<br>2. **Count Words Equal To (word)**:<br>    <br>    - Traverse through the Trie following each character in `word`.<br>    - If any character path doesn’t exist, return 0 (the word doesn’t exist).<br>    - At the end of `word`, return the `wordCount` of the last node.<br>3. **Count Words Starting With (prefix)**:<br>    <br>    - Traverse the Trie following each character in `prefix`.<br>    - If any character path doesn’t exist, return 0 (no words with that prefix exist).<br>    - At the end of `prefix`, return the `prefixCount` of the last node, which represents how many words start with that prefix.<br>4. **Erase (word)**:<br>    <br>    - Traverse through the Trie following each character in `word`.<br>    - Decrease `prefixCount` by 1 at each node.<br>    - When reaching the end of `word`, decrease the `wordCount` by 1 to remove one occurrence of that word.<br>https://takeuforward.org/data-structure/implement-trie-ii/ |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| String                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Longest Substring Without Repeating Characters](https://takeuforward.org/data-structure/length-of-longest-substring-without-any-repeating-character/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                          | Instead of keeping count, keep the index of character and also a curent_start of sliding window<br><br>To solve the **Longest Substring Without Repeating Characters** problem, use a sliding window approach with two pointers: one to mark the start of the current substring and the other to expand it by iterating through each character in the string. Keep track of characters in a set or map, and when a duplicate character is found, move the start pointer rightward until the substring no longer contains duplicates. Track the maximum length of any substring encountered without duplicates to get the solution.<br><br>function longestSubstringWithoutRepeating(s):<br>    initialize maxLength = 0<br>    initialize start = 0<br>    create a map to store character indices (charIndexMap)<br><br>    for end from 0 to length of s - 1:<br>        if s[end] is in charIndexMap:<br>            // Move the start pointer to the right of the duplicate character's last occurrence<br>            start = max(start, charIndexMap[s[end]] + 1)<br>        <br>        // Update the character's latest index in the map<br>        charIndexMap[s[end]] = end<br><br>        // Update the maximum length<br>        maxLength = max(maxLength, end - start + 1)<br><br>    return maxLength<br>                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| longest repeating character replacement<br><br>Given a string `s` and an integer `k`, the goal is to find the length of the longest substring where you can change up to `k` characters to make all characters in the substring the same.                                                                                                                                                                                                                                                                                                                                                         | ### Approach to Solve the Problem<br><br>1. **Sliding Window with Frequency Count**:<br>    <br>    - Use a sliding window approach with two pointers: one (`start`) to mark the beginning of the window and another (`end`) to expand the window.<br>    - Track the frequency of each character within the window and keep track of the count of the most frequent character in the current window.<br>2. **Window Condition**:<br>    <br>    - For a window to be valid, the number of characters in the window minus the count of the most frequent character should be less than or equal to `k`.<br>    - If this condition isn’t met, increment the `start` pointer to shrink the window.<br>3. **Result**:<br>    <br>    - Track the maximum length of a valid window.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Minimum Window Substring<br><br>Given two strings, `s` (the source string) and `t` (the target string), find the smallest substring in `s` that contains all characters in `t`. If there is no such substring, return an empty string. If there are multiple possible answers, return the first one found.                                                                                                                                                                                                                                                                                        | ### Approach to Solve the Problem<br><br>1. **Sliding Window with Frequency Count**:<br>    <br>    - Use two pointers (`start` and `end`) to create a sliding window in `s` and a frequency map to keep track of the counts of each character in `t`.<br>    - Expand the window by moving `end` and add characters to the window’s character count until the window contains all characters in `t` with the required frequencies.<br>2. **Shrink the Window**:<br>    <br>    - Once all characters are present in the window, move the `start` pointer to shrink the window and try to find a smaller valid substring.<br>    - Track the minimum window length and its position whenever a valid window is found.<br>3. **Result**:<br>    <br>    - If a valid window was found, return the substring. If no such window exists, return an empty string.<br><br>[[minimum window substring]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| \|\|Check for Anagrams\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | To check if two strings are anagrams, first confirm they have the same length; if not, they can’t be anagrams. Then, use a frequency counter (like a HashMap) to count occurrences of each character in the first string and decrease the count for each character in the second string. Finally, verify if all counts are zero; if they are, the strings are anagrams.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Group Anagrams<br><br>Given an array of strings `strs`, group the anagrams together.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | - **Use a HashMap**:<br>    <br>    - Create a HashMap where the key is a representation of the characters in the string (typically sorted characters or a character count array), and the value is a list of strings (anagrams) that correspond to that key.<br>- **Character Sorting or Counting**:<br>    <br>    - For each string in the input array:<br>        - Sort the characters in the string and use the sorted string as a key in the HashMap.<br>        - Alternatively, count the occurrences of each character (using an array of size 26 for lowercase letters) to create a unique key.<br>- **Group Anagrams**:<br>    <br>    - For each string, add it to the list in the HashMap corresponding to its key.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Map<String, List<String>> anagramMap = new HashMap<>(); for (String str : strs) { // Sort the string to create a key char[] charArray = str.toCharArray(); Arrays.sort(charArray); String sortedKey = new String(charArray); // Add the original string to the list of anagrams anagramMap.putIfAbsent(sortedKey, new ArrayList<>()); anagramMap.get(sortedKey).add(str); }                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Check for balanced paranthesis](https://takeuforward.org/data-structure/check-for-balanced-parentheses/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | - **Initialize a Stack:** We'll use a stack to keep track of opening parentheses.  <br>    <br>- **Iterate through the String:**<br>    - If the current character is an opening parenthesis, push it onto the stack.  <br>        <br>    - If the current character is a closing parenthesis:<br>        - If the stack is empty, the string is unbalanced.<br>        - Pop the top element from the stack.<br>        - If the popped element doesn't match the current closing parenthesis, the string is unbalanced.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| \|Longest Palindromic Substring[Do it without DP]\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Expand around centre <br>or <br>**Manacher's Algorithm**.<br><br>Helps to optmially find the next centre<br>WE should pick such a point as next center such that the palindrome around it expands till the right edge of characters we have explored till now                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Palindromic Substrings<br>return _the number of **palindromic substrings** in it_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Similar approach as previous or DP                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Linked List                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Reverse a LinkedList](https://takeuforward.org/data-structure/reverse-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | To reverse a linked list, you need to iterate through the list while keeping track of three pointers: **previous**, **current**, and **next**. For each node, update its `next` pointer to point to the previous node, then move the pointers one step forward (i.e., `previous` becomes `current`, `current` becomes `next`). Continue this until all nodes have been reversed, and at the end, `previous` will be the new head of the reversed list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Detect a cycle in Linked List](https://takeuforward.org/data-structure/detect-a-cycle-in-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | fast pointer and slow pointer collison                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| <br>\|[Merge two sorted Linked List (use method used in mergeSort)](https://takeuforward.org/data-structure/merge-two-sorted-linked-lists/)\|[](https://takeuforward.org/data-structure/merge-two-sorted-linked-lists/)\|\|[<br><br>](https://leetcode.com/problems/merge-two-sorted-lists/)\|\|                                                                                                                                                                                                                                                                                                  | To merge two sorted linked lists, initialize a dummy node to simplify the process, and use two pointers, one for each list, to compare nodes. Iteratively link the smaller of the two nodes to the merged list, advancing the pointer in that list, until one list is exhausted. Finally, link the remaining part of the non-empty list to the merged list, and return the merged list starting from the dummy node's next pointer.<br><br>4o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Merge K sorted arrays                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | To merge kkk sorted arrays, use a **min-heap (priority queue)** to efficiently track the smallest current element from each array. Insert the first element of each array into the heap, and then repeatedly extract the smallest element from the heap, adding it to the merged list and pushing the next element from that array into the heap. Continue until all elements from every array have been added to the merged list, ensuring an optimal O(nlog⁡k)O(n \log k)O(nlogk) time complexity, where nnn is the total number of elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Remove N-th node from back of LinkedList](https://takeuforward.org/data-structure/remove-n-th-node-from-the-end-of-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                               | To remove the NNN-th node from the end of a linked list, use the **two-pointer technique** by starting two pointers, `fast` and `slow`, at the head. Move the `fast` pointer NNN nodes ahead, then move both pointers one step at a time until `fast` reaches the end, with `slow` pointing to the node before the target. Finally, adjust `slow.next` to skip the target node, effectively removing it from the list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Reorder List](https://takeuforward.org/data-structure/reorder-list/)<br>The **Reorder List** problem requires rearranging a singly linked list so that the nodes appear in a specific alternating order. Given a linked list L0→L1→L2→⋯→LnL_0 \rightarrow L_1 \rightarrow L_2 \rightarrow \dots \rightarrow L_nL0​→L1​→L2​→⋯→Ln​, we want to reorder it to L0→Ln→L1→Ln−1→L2→Ln−2…L_0 \rightarrow L_n \rightarrow L_1 \rightarrow L_{n-1} \rightarrow L_2 \rightarrow L_{n-2} \dotsL0​→Ln​→L1​→Ln−1​→L2​→Ln−2​…. In other words, we rearrange the list to alternate nodes from the start and end. | To achieve this reordering efficiently, we can break down the solution into three main steps:<br><br>1. **Find the Middle of the List**:<br>    <br>    - Use the **fast and slow pointer technique** to find the middle node of the list. The `slow` pointer moves one step at a time, while the `fast` pointer moves two steps. By the time the `fast` pointer reaches the end, the `slow` pointer will be at the middle.<br>2. **Reverse the Second Half**:<br>    <br>    - Once we have the middle node, separate the list into two halves. Reverse the second half of the list starting from the node after the middle node. This reversal allows us to easily access nodes from the end in the new ordering.<br>3. **Merge the Two Halves**:<br>    <br>    - With two pointers (one starting at the head of the list and the other at the head of the reversed second half), alternately merge nodes from the two halves. This merges the nodes in the order required by the problem.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Interval                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Insert Interval](https://leetcode.com/problems/insert-interval/)<br>2 array list<br>you have a list of non-overlapping intervals sorted by their start times and need to insert a new interval while maintaining order and merging any overlapping intervals                                                                                                                                                                                                                                                                                                                                     | Given a list of intervals `[[1, 3], [6, 9]]` and a new interval `[2, 5]`, the output should be `[[1, 5], [6, 9]]`.<br><br>### Steps to Solve the Problem<br><br>1. **Iterate Through Existing Intervals**:<br>    <br>    - Initialize an empty list to hold the result.<br>    - Traverse each interval in the list and check its relation to the new interval.<br>2. **Three Cases for Each Interval**:<br>    <br>    - **No Overlap, Before New Interval**: If the current interval ends before the new interval starts, add it directly to the result list.<br>    - **No Overlap, After New Interval**: If the current interval starts after the new interval ends, add the new interval to the result list (if not already added), then add the current interval, and continue with the rest.<br>    - **Overlap with New Interval**: If there is an overlap (i.e., the current interval starts before the new interval ends), merge them by updating the start to the minimum of both starts and the end to the maximum of both ends.<br>3. **Add Remaining Interval**:<br>    <br>    - If the new interval has not yet been added by the end of the loop, add it to the result list.<br><br>                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Merge Intervals](https://leetcode.com/problems/merge-intervals/)<br>Single Array List<br>Given an array of `intervals` where `intervals[i] = [starti, endi]`, merge all overlapping intervals, and return _an array of the non-overlapping intervals that cover all the intervals in the input_.<br>**Input:** intervals = [[1,3],[2,6],[8,10],[15,18]]<br>**Output:** [[1,6],[8,10],[15,18]]                                                                                                                                                                                                    | ### Steps to Solve the Problem<br><br>1. **Sort the Intervals**:<br>    <br>    - Start by sorting the intervals by their start times. This will make it easier to identify overlapping intervals, as they’ll be adjacent in sorted order.<br>2. **Initialize the Result List**:<br>    <br>    - Use an empty list to store the merged intervals.<br>    - Start with the first interval in the sorted list as the "current" interval to be compared against.<br>3. **Iterate Through Intervals**:<br>    <br>    - For each subsequent interval, check if it overlaps with the "current" interval:<br>        - **If Overlapping**: Merge the two by updating the end of the "current" interval to the maximum end of both intervals.<br>        - **If Not Overlapping**: Add the "current" interval to the result list and update "current" to the next interval.<br>4. **Add the Last Interval**:<br>    <br>    - After the loop, add the last "current" interval to the result list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Non-overlapping Intervals](https://leetcode.com/problems/non-overlapping-intervals/)<br>Given an array of intervals `intervals` where `intervals[i] = [starti, endi]`, return _the minimum number of intervals you need to remove to make the rest of the intervals non-overlapping_.                                                                                                                                                                                                                                                                                                            | - **Sort the Intervals by End Time**:<br>    <br>    - Start by sorting intervals by their end times in ascending order. This way, you can select the interval that ends the earliest, maximizing the space for subsequent non-overlapping intervals.<br>- **Greedily Count Non-overlapping Intervals**:<br>    <br>    - Initialize a counter for the number of non-overlapping intervals and a variable to keep track of the end of the last added interval.<br>    - Traverse through each interval:<br>        - If the start of the current interval is greater than or equal to the end of the last selected interval, it doesn’t overlap. Increment the count and update the end time to the end of the current interval.<br>        - If it overlaps, ignore it (this effectively counts as "removing" the interval).<br>- **Calculate the Minimum Removals**:<br>    <br>    - The minimum number of intervals to remove is the total number of intervals minus the count of non-overlapping intervals.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Repeat and Missing Number](https://takeuforward.org/data-structure/find-the-repeating-and-missing-numbers/)<br>problem gives you an array of nnn integers, where the integers are supposed to be from 1 to n, but one number is repeated, and one number is missing.Your task is to identify the repeated number and the missing number.                                                                                                                                                                                                                                                         | Approach 1: Hashing <br>nstead of counting the occurrences every time, using the hashing technique, we will store the frequency of each element between 1 to N. Now, the element with frequency 2 will be the repeating number and the element with frequency 0 will be the missing number. (But this takes extra space )<br><br>Approach 2: XOR (need to understand it better)<br><br>Approach 3: Math<br>steps<br><br>1. original correct sequence -> a<br>2. new sequence with missing and repeat num -> b<br>3. sum of sq of nums in sequence a -> a2<br>4. Sum of sq of num in sequence b-> b2<br><br>(a+b)(a-b)= (a2-b-2)<br><br>summation of original expected sequence a will be -> n*(n+1)/2<br><br>Summation of squares will be -> (N*(N+1)*(2N+1))/6<br><br>So we will be able to find a-b<br>thus we will now a and b. <br>[[Repeat and missing Number]]<br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Meeting room 1<br>Given an array of meeting time intervals `[[start1, end1], [start2, end2], ...]`, determine if a person could attend all meetings without any overlaps.                                                                                                                                                                                                                                                                                                                                                                                                                         | - **Sort the Intervals**:<br>    <br>    - First, sort the intervals by their start times. This way, you only need to check each meeting against the one immediately after it.<br>- **Check for Overlaps**:<br>    <br>    - After sorting, go through the intervals. For each interval, compare its end time to the start time of the next interval.<br>    - If an interval's end time is greater than the next interval's start time, there is an overlap, and the answer is "no" (the person cannot attend all meetings).<br>    - If no overlaps are found by the end of the list, the answer is "yes" (the person can attend all meetings).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Meeting rooms 2<br>> **Problem**: Given an array of meeting time intervals `[[start1, end1], [start2, end2], ...]`, determine the minimum number of conference rooms required so that all meetings can take place without overlap.                                                                                                                                                                                                                                                                                                                                                                | - **Sort the Intervals**:<br>    - Sort the intervals by their start times.<br>- **Use a Min-Heap**:<br>    - Use a min-heap (a priority queue) to keep track of the end times of meetings currently occupying rooms.<br>    - As you iterate over the sorted meetings, you’ll add and remove meeting end times to manage room availability.<br>- **Algorithm Steps**:<br>    <br>    - Sort the intervals based on their start times.<br>    - Initialize a min-heap to store end times.<br>    - For each interval:<br>        - If the meeting’s start time is greater than or equal to the smallest end time in the heap, pop the smallest end time (i.e., a room has become free).<br>        - Push the current meeting’s end time onto the heap.<br>    - The size of the heap at the end represents the minimum number of rooms needed, as it shows the maximum number of concurrent meetings.<br><br> **The reason min heap last size works is bcz even if in mid of array there were the highest number of parallel meeting and there after less, still if you pop heap it's size will still contain the max number of parallel meetings**                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| <br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Course schedule II<br><br>Given the total number of **n** tasks and a list of prerequisite pairs of size **m**. Find a ordering of tasks you should pick to finish all tasks.                                                                                                                                                                                                                                                                                                                                                                                                                     | To solve "Course Schedule II," think of the problem as a graph where courses are nodes and prerequisites are directed edges. Use topological sorting to find a valid course order by adding courses with no prerequisites (in-degree of 0) to a queue and processing them one by one. If you can order all courses, there’s no cycle; otherwise, return an empty array.<br><br>so this a cannot be solved by only DFS<br>it can only be solved by BFS and topological sort or DFS with Topo sort                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Matrix                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Set Matrix Zeros](https://takeuforward.org/data-structure/set-matrix-zero/)<br>Given an `m x n` matrix, if an element is 0, set its entire row and column to 0. You must do it **in-place**.                                                                                                                                                                                                                                                                                                                                                                                                     | - Use the first row and first column as markers to track which rows and columns should be set to zero.<br>- In the first pass, mark the respective first row/column cells for any zero found in the matrix.<br>- In the second pass, use these markers to update the matrix, and handle the first row/column separately to avoid overwriting the markers prematurely.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Print the matrix in spiral manner](https://takeuforward.org/data-structure/spiral-traversal-of-matrix/)<br>Given an `m x n` matrix, print its elements in **spiral order**.                                                                                                                                                                                                                                                                                                                                                                                                                      | - Use four boundaries (`top`, `bottom`, `left`, and `right`) to define the current layer of the matrix.<br>- Traverse the matrix in four steps: left-to-right across the `top`, top-to-bottom along the `right`, right-to-left across the `bottom`, and bottom-to-top along the `left`, updating boundaries after each step.<br>- Continue until the `top` boundary crosses the `bottom` or the `left` boundary crosses the `right`.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Rotate Matrix by 90 degrees](https://takeuforward.org/data-structure/rotate-image-by-90-degree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | - To rotate the matrix, first **transpose it** by swapping elements across the diagonal (swap `matrix[i][j]` with `matrix[j][i]`).<br>- Then, **reverse each row** to shift the columns into the correct rotated position.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Word Search](https://takeuforward.org/data-structure/word-search-leetcode/)<br>The **Word Search** problem involves finding whether a given word exists in a 2D character grid.  <br>The word can be constructed from adjacent cells (horizontally or vertically), and the same cell cannot be reused for multiple characters.                                                                                                                                                                                                                                                                   | - Start backtracking from each cell in the matrix and explore all 4 possible directions to match the word.<br>- Use a "visited" marker to prevent reusing the same cell during the current path.<br>- If you match all characters in the word, return `true`; otherwise, backtrack and try other paths.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
