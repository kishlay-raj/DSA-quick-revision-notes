
| Question                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | Hint to remember                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Coding hint                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Misktake to avoid                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Not solved     | Revision needed        |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | -------------- | ---------------------- |
| <br>\|[2Sum Problem](https://takeuforward.org/data-structure/two-sum-check-if-a-pair-with-given-sum-exists-in-array/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | use a hash map to store the difference between the target and each element as you iterate through the array. Check if the current element exists in the map; if so, you've found the pair that sums to the target.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| \|   \|   \|<br>\|---\|---\|<br>\|\|[Best Time to Buy and Sell Stock \|(DP-35)](https://takeuforward.org/data-structure/stock-buy-and-sell-dp-35/)\|<br>We can buy and sell only once                                                                                                                                                                                                                                                                                                                                                                                                             | maintain two arrays:<br><br>1. **Left Min Array:** Track the minimum price up to each day.<br>2. **Right Max Profit Array:** Track the maximum profit achievable if you sold on each day.<br><br>At the end, compute the maximum difference between prices by comparing the current price and the minimum from the left array. This approach mimics the logic of DP by reusing precomputed values to optimize the solution.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Contains Duplicate](https://takeuforward.org/data-structure/contains-duplicate-check-if-a-value-appears-atleast-twice/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | use hashset                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Product of Array Except Self<br>eg.<br>**Input:** N = 5, array[] = {1,2,3,4,5}<br>**Output**: 120 60 40 30 24                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | use two passes: in the first pass, calculate the running product of all elements to the left of each index, and in the second pass, calculate the running product of elements to the right while multiplying it with the left product from the first pass.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Kadane's Algorithm, maximum subarray sum](https://takeuforward.org/data-structure/kadanes-algorithm-maximum-subarray-sum-in-an-array/)                                                                                                                                                                                                                                                                                                                                                                                                                                                           | maintaining a running sum of the current subarray, resetting it to the current element if the sum becomes negative. The maximum subarray sum is updated whenever the current running sum exceeds the previously recorded maximum.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Find minimum in Rotated Sorted Array](https://takeuforward.org/data-structure/minimum-in-rotated-sorted-array/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | To solve the "Find Minimum in Rotated Sorted Array" problem, use binary search by comparing the middle element with the rightmost element. If the middle element is greater than the rightmost, the minimum lies in the right half; otherwise, it lies in the left half, narrowing down until the minimum is found.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Search in Rotated Sorted Array I](https://takeuforward.org/data-structure/search-element-in-a-rotated-sorted-array/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | 1. **Identify the sorted half:** In each iteration, compare the middle element with the left and right bounds to determine which half of the array is sorted.<br>    <br>    - If the left half is sorted, check if the target lies within the range of the left half (i.e., between the left and mid elements).<br>    - If the right half is sorted, check if the target lies within the range of the right half (i.e., between the mid and right elements).<br>2. **Adjust the search range:** Based on the sorted half and the targetâ€™s value, discard the irrelevant half and continue the binary search on the remaining half.<br>    <br><br>Repeat this process until the target is found or the search space is exhausted.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [3 sum](https://takeuforward.org/data-structure/3-sum-find-triplets-that-add-up-to-a-zero/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | To solve the 3 Sum problem, first sort the array and then use a two-pointer approach: for each element, treat it as a fixed element and use two pointers (one starting right after the fixed element and the other from the end of the array) to find two other numbers that sum to the target (negative of the fixed element). Adjust the pointers based on the sum, and skip duplicates to avoid repeated triplets.[[3 sum]]<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Container with most water                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | Use two pointers, one at the beginning and one at the end of the array. Calculate the area between the two pointers, move the pointer with the smaller height inward, and repeat until the pointers meet to maximize the container area.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| <br>Binary<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | Learn how to shift bits to create or reduce a number. <br>create notes on standard operations                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Sum of Two Integers                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | - Use XOR (`^`) to add the bits of `a` and `b` without considering the carry.<br>- Use AND (`&`) to calculate the carry, then shift it left by 1 (`<< 1`).<br>- Repeat the process until the carry becomes 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | def getSum(a, b):<br>    while b != 0:<br>        carry = a & b         # Calculate carry<br>        a = a ^ b             # Sum without carry<br>        b = carry << 1        # Shift carry left<br>    return a<br><br># Example usage:<br>result = getSum(3, 5)  # Output will be 8<br>print(result)<br>                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | No solved yet  |                        |
| [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | To solve the **Number of 1 Bits** problem, repeatedly check the least significant bit of the number using `n & 1`, then right-shift the number by one bit (`n >> 1`) to check the next bit. Count how many times the result is 1 until the number becomes 0.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | def hammingWeight(n):<br>    count = 0<br>    while n:<br>        count += n & 1  # Check if the least significant bit is 1<br>        n >>= 1         # Right shift to check the next bit<br>    return count<br><br><br>                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| [Counting Bits](https://leetcode.com/problems/counting-bits/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | you count the number of 1s in the binary representation for each number from 0 to `n`,[[Counting Bits]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| [Missing Number](https://leetcode.com/problems/missing-number/)<br>Find the only missing number between 0-n from array                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | Use the formula for the sum of the first `n` numbers: `sum = n * (n + 1) / 2`. Subtract the sum of the array elements from this expected sum to find the missing number.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| [Reverse Bits](https://leetcode.com/problems/reverse-bits/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | To solve the **Reverse Bits** problem, iterate over all 32 bits of the number, extract each bit using bitwise operations, and shift it into the reversed position in a result variable. Shift the result left to make space for the next bit, and shift the input number right to process the next bit.[[reverseBits]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved yet |                        |
| Graph                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Clone Graph](https://leetcode.com/problems/clone-graph/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | To solve the **Clone Graph** problem, use a breadth-first search (BFS) or depth-first search (DFS) to traverse the graph. As you visit each node, create a clone of that node and map it to the original node. Then, for each neighbor of the original node, ensure you clone it if it hasn't been cloned yet, and connect the cloned nodes accordingly.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | make sure that you track the visited node                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                |                        |
| [Course Schedule](https://leetcode.com/problems/course-schedule/)<br>You must take course B before you take course A. Return true if u can finish all courses.                                                                                                                                                                                                                                                                                                                                                                                                                                    | Basically we have to find if the graph is **cyclic** <br>Use **topological sorting** or **DFS cycle detection**:<br><br>- For **topological sorting**, try to track courses with no prerequisites (in-degree 0) and process them first.<br>- For **DFS**, try marking courses as being visited, and if you revisit a course thatâ€™s still being processed, you found a cycle.[[course schedule]]<br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     | not solved     |                        |
| [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)<br>Find coordinates from where water can flow to both Pacific and Atlantic ocean [[pacific Atlantic water flow]]<br>                                                                                                                                                                                                                                                                                                                                                                                    | You need to simulate water flowing **from the oceans** rather than trying to track water flow to the oceans.Think of starting at the edges (where the oceans touch the grid), and figure out which cells can reach both the **Pacific** and **Atlantic** by using Depth First Search (DFS) or Breadth First Search (BFS)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | **Key observation**: For water to flow from one cell to another, the destination cell must be **equal or lower in height** than the current cell.<br><br>Start loop from all 4 corners and mark the ones which are reachable from Atlantic and Pacific.<br><br>Common ones present in both will be the answer.                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Number of Islands](https://leetcode.com/problems/number-of-islands/)<br>In a matrix containing 0s &1s, find the number of islands                                                                                                                                                                                                                                                                                                                                                                                                                                                                | The problem can be reduced to finding the number of **connected components** in this graph<br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Longest Consecutive Sequence](https://leetcode.com/problems/longest-consecutive-sequence/)<br>Given an unsorted array of integersÂ `nums`, returnÂ _the length of the longest consecutive elements sequence._<br><br>You must write an algorithm that runs inÂ `O(n)`Â time.<br>**We have to solve it regardless of order.**                                                                                                                                                                                                                                                                         | - First, we will put all the array elements into the set data structure.<br>- If a number, num, is a starting number, ideally, num-1 should not exist. So, for every element, x, in the set, we will check if x-1 exists inside the set. :<br>    - **If x-1 exists:**Â This means x cannot be a starting number and we will move on to the next element in the set.<br>    - **If x-1 does not exist:**Â This means x is a starting number of a sequence. So, for number, x, we will start finding the consecutive elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | mistake to avoid:<br><br>- Treating duplicates as separate nodes in the graph.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                |                        |
| [Alien dictionary](https://takeuforward.org/data-structure/alien-dictionary-topological-sort-g-26/)<br>Given a sorted dictionary of an alien language having N words and k starting alphabets of a standard dictionary. Find the order of characters in the alien language.                                                                                                                                                                                                                                                                                                                       | The problem can be reduced to **topological sorting** of a directed acyclic graph (DAG)<br><br>Comparing each pair of consecutive words in the dictionary, we can construct a directed graph like the following:<br><br>How to build the graph?<br>For each pair of adjacent words, compare characters until you find the first mismatch. This mismatch indicates the order of the characters<br><br>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           | 1. **Not Handling the Prefix Case Correctly**<br><br>**Mistake**: Failing to handle the case where one word is a prefix of another word. For example, in the input `["abc", "ab"]`, `"abc"` appears before `"ab"`, which is invalid because `"ab"` should come first in lexicographical order.<br><br>**How to Avoid**: If `word2` is a **prefix** of `word1`, and `word1` is longer than `word2`, the input dictionary is invalid. You need to detect this case and return an empty result.<br><br>if len(word1) > len(word2) and word1[:min_len] == word2[:min_len]:<br>    return ""  # Invalid case: no valid order<br><br>Mistake 2:<br>**Not Detecting Cycles in the Graph**                                                                                                                                                                                                                                                                                                  |                |                        |
| Graph Valid Tree<br>The **Graph Valid Tree** problem asks you to determine if a given graph is a **valid tree**. A tree is an **undirected, connected graph** with **no cycles** and exactly **n-1 edges** where `n` is the number of nodes.                                                                                                                                                                                                                                                                                                                                                      | To solve the **Graph Valid Tree** problem:<br><br>1. First, check if the number of edges is exactly `n-1` (a necessary condition for a tree).<br>2. Use **DFS/BFS** to ensure the graph is **connected** and detect any **cycles**.<br>3. Finally, verify that all nodes have been visited to ensure full connectivity.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| https://takeuforward.org/graph/connected-components-in-graphs/<br>requires identifying distinct **subgraphs** within a graph                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | use **DFS** or **BFS** to explore the graph, marking visited nodes. Start a new traversal for each unvisited node, and count how many times you initiate a new traversal to get the number of connected components.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Tree                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Height of a Binary Tree](https://takeuforward.org/data-structure/maximum-depth-of-a-binary-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | The **recursive DFS approach** is optimal for finding the height of a tree,                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        | def find_height(node):<br>    if node is None:<br>        return -1  # For 0-based height, or return 0 for height in terms of number of nodes<br>    left_height = find_height(node.left)<br>    right_height = find_height(node.right)<br>    return max(left_height, right_height) + 1<br>                                                                                                                                                                                                                                              | In recursive approaches, ensure you return `-1` for null nodes (for 0-based height) or `0` (for node-count based height) in the base case, depending on how height is defined in your problem.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                | try to solve using BFS |
| [Check if two trees are identical or not](https://takeuforward.org/data-structure/check-if-two-trees-are-identical/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | To check if two trees are identical, compare the root values and recursively check if both the left and right subtrees are identical. The trees are identical if both are empty or if their structures and node values match exactly at each level.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                | def are_identical(tree1, tree2):<br>    if tree1 is None and tree2 is None:<br>        return True<br>    if tree1 is not None and tree2 is not None:<br>        return (tree1.value == tree2.value and <br>                are_identical(tree1.left, tree2.left) and <br>                are_identical(tree1.right, tree2.right))<br>    return False<br>                                                                                                                                                                                |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| <br>\|[Invert/Flip Binary Tree (Create)](https://takeuforward.org/data-structure/check-for-symmetrical-binary-tree/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | To invert or flip a binary tree, recursively swap the left and right child of each node. Traverse the tree and for each node, invert its left and right subtrees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | def invert_tree(node):<br>    if node:<br>        node.left, node.right = invert_tree(node.right), invert_tree(node.left)<br>    return node<br>                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Find Symmetric trees                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | To check if two trees are symmetric, recursively compare them to see if one tree is the mirror image of the other. The trees are symmetric if the left subtree of one tree matches the right subtree of the other and vice versa.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | def are_symmetric(tree1, tree2):<br>    if tree1 is None and tree2 is None:<br>        return True<br>    if tree1 and tree2:<br>        return (tree1.value == tree2.value and <br>                are_symmetric(tree1.left, tree2.right) and <br>                are_symmetric(tree1.right, tree2.left))<br>    return False<br>                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Maximum path sum](https://takeuforward.org/data-structure/maximum-sum-path-in-binary-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | To solve the **Maximum Path Sum** in a binary tree, you need to find the maximum sum of node values in any path, where the path can start and end at any node. The solution involves a recursive DFS approach to calculate the maximum path sum passing through each node and keeping track of the global maximum.<br><br>### Key Steps:<br><br>1. For each node, compute the maximum sum of a path that includes the node and one of its subtrees (left or right).<br>2. Update the global maximum with the sum of the node's value and the maximum sums from both left and right subtrees (if applicable).<br>3. Return the maximum sum for each subtree path to its parent (only one subtree can be included in the return path).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | def max_path_sum(node):<br>    def helper(node):<br>        if not node:<br>            return 0<br>        left = max(helper(node.left), 0)  # ignore negative paths<br>        right = max(helper(node.right), 0)<br>        local_max = node.value + left + right  # max path through this node<br>        global_max[0] = max(global_max[0], local_max)<br>        return node.value + max(left, right)  # return max single path upwards<br><br>    global_max = [-float('inf')]<br>    helper(node)<br>    return global_max[0]<br> | - **Not Handling Negative Values**: Ensure that you correctly handle paths with negative sums by ignoring them when calculating maximum paths. Use `max(helper(node.left), 0)` to avoid adding negative contributions.<br><br>**Misunderstanding Path Definition**: Remember that the path can start and end at any node, and it can include both subtrees of a node. Don't limit your calculations to just left or right subtrees; consider paths that pass through the current node.<br><br>- **Incorrectly Updating Global Maximum**: Ensure that you update the global maximum path sum every time you compute a new local maximum path that passes through the current node, which includes contributions from both left and right subtrees.<br>    <br>- **Returning Incorrect Values**: When returning from the recursive function, only return the maximum sum of the path that can be extended to the parent node, not the total maximum path that includes both subtrees. |                | imp to revise          |
| [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)<br>Given theÂ `root`Â of a binary tree, returnÂ _the zigzag level order traversal of its nodes' values_. (i.e., from left to right, then right to left for the next level and alternate between                                                                                                                                                                                                                                                                                  | perform a level-order traversal using a queue while keeping track of the current direction (left to right or right to left). By alternating the direction with each level, I can easily collect the node values in the desired order.<br><br>Note: The way we traverse the node of a level is ALWAYS from left to right. Only when these nodes are inserted into the final result list are they reversed. We can alternatively keep changing the value of the boolean value to reverse every alternate levels.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| \|[Serialize and deserialize Binary Tree](https://takeuforward.org/data-structure/serialize-and-deserialize-a-binary-tree/)\|<br><br>imp: watch video solution <br>https://youtu.be/-YbXySKJsX8                                                                                                                                                                                                                                                                                                                                                                                                   | **Step 1:**Â Check if the tree is empty: If the root is null, return an empty string.<br><br>**Step 2:**Â Initialise an empty string: This string will store the serialised binary tree.<br><br>**Step 3:**Â Use a queue for level-order traversal: Initialise a queue and enqueue the root.<br><br>![](https://static.takeuforward.org/content/serialise-deserialise-image5-rCwIAtKs)<br><br>**Step 4:**Â Within the level-order traversal loop:<br><br>1. Dequeue a node from the queue.<br>2. If the node is null, append "#" to the string.<br>3. If the node is not null, append its data value along with a â€˜,â€™ (comma) to the string. This comma acts as a delimiter that separates the different node values in the string. Enqueue its left and right children.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | ![[Pasted image 20241020223148.png]]<br><br>imp watch this video https://youtu.be/-YbXySKJsX8                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Subtree of Another Tree](https://takeuforward.org/data-structure/subtree-of-another-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       | - Traverse the main tree to find nodes that match the root of the subtree.<br>- Once a potential match is found, recursively compare both the left and right children of the nodes in the main tree and subtree.<br>- Return true if an identical subtree structure is found, otherwise continue searching in the left or right subtrees.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| <br>\|\|[Construct the Binary Tree from Postorder and Inorder Traversal](https://takeuforward.org/data-structure/construct-binary-tree-from-inorder-and-postorder-traversal/)\|                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Check if a tree is a BST or BT                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    | - A binary search tree (BST) follows the property where for each node, the left subtree contains values smaller than the node and the right subtree contains values larger.<br>- Perform an in-order traversal and check if the nodes are visited in strictly increasing order.<br>- If any node violates the order during traversal, the tree is not a BST.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Find K-th smallest element in BST](https://takeuforward.org/data-structure/kth-largest-smallest-element-in-binary-search-tree/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | - Perform an in-order traversal of the BST, as it visits nodes in ascending order.<br>- Keep a counter during the traversal and stop when the counter reaches `k`.<br>- The node at that point will be the `k`th smallest element in the BST.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Find kth largest element in BST                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | - Perform a reverse in-order traversal (right, root, left) on the BST to visit nodes in descending order.<br>- Keep a counter and stop the traversal once it reaches `k`.<br>- The node at that point will be the `k`th largest element in the BST.<br><br>or <br>**Augmented Tree with Node Counts**: Modify each node in the BST to store the count of nodes in its left and right subtrees. Using this information, you can determine the kkkth largest by navigating directly, based on the counts, without a full traversal.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Find LCA of two nodes in BST                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      | - Start at the root and compare the values of the two nodes with the current node.<br>- If both nodes are smaller than the current node, move to the left child; if both are larger, move to the right child.<br>- The first node where one value is smaller and the other is larger (or one matches the current node) is the Lowest Common Ancestor (LCA).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Implement Trie (Prefix Tree)](https://takeuforward.org/data-structure/implement-trie-1/)<br><br>1. insert<br>2. Search<br>3. Start with                                                                                                                                                                                                                                                                                                                                                                                                                                                          | 1. **`insert(String word)`**:<br>    <br>    - Converts each character to an index (`ch - 'a'`) and adds nodes to the Trie if they donâ€™t exist at each level.<br>    - Marks the end of the word when the word is fully inserted.<br>2. **`search(String word)`**:<br>    <br>    - Checks each character in the word to see if the path exists in the Trie.<br>    - Returns `true` if all characters are found and the last node is marked as the end of a word.<br>3. **`startsWith(String prefix)`**:<br>    <br>    - Similar to `search`, but it doesnâ€™t check `isEndOfWord`, only confirming if the path for the prefix exists.<br><br>Detail:[[Trie - Search, insert, Prefix]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Implement Trie - 2 (Prefix Tree)](https://takeuforward.org/data-structure/implement-trie-ii/)<br>1. Insert<br>2. Count words equal to word: Return the count of occurrences of the string <br>3. count words starting with Prefix<br>4. Erase: Delete one occurrence of the string                                                                                                                                                                                                                                                                                                               | To solve this, weâ€™ll use an enhanced Trie structure where each `TrieNode` keeps track of:<br><br>- How many times words pass through that node (`prefixCount`).<br>- How many times that node marks the end of a word (`wordCount`).<br><br>### Explanation of Each Operation<br><br>1. **Insert (word)**:<br>    <br>    - For each character in `word`, navigate through the Trie, creating nodes if they donâ€™t exist.<br>    - Increment `prefixCount` at each node to indicate a word passes through it.<br>    - When reaching the end of `word`, mark the end node and increment its `wordCount`.<br>2. **Count Words Equal To (word)**:<br>    <br>    - Traverse through the Trie following each character in `word`.<br>    - If any character path doesnâ€™t exist, return 0 (the word doesnâ€™t exist).<br>    - At the end of `word`, return the `wordCount` of the last node.<br>3. **Count Words Starting With (prefix)**:<br>    <br>    - Traverse the Trie following each character in `prefix`.<br>    - If any character path doesnâ€™t exist, return 0 (no words with that prefix exist).<br>    - At the end of `prefix`, return the `prefixCount` of the last node, which represents how many words start with that prefix.<br>4. **Erase (word)**:<br>    <br>    - Traverse through the Trie following each character in `word`.<br>    - Decrease `prefixCount` by 1 at each node.<br>    - When reaching the end of `word`, decrease the `wordCount` by 1 to remove one occurrence of that word.<br>https://takeuforward.org/data-structure/implement-trie-ii/ |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| String                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Longest Substring Without Repeating Characters](https://takeuforward.org/data-structure/length-of-longest-substring-without-any-repeating-character/)\|                                                                                                                                                                                                                                                                                                                                                                                                                                          | Instead of keeping count, keep the index of character and also a curent_start of sliding window<br><br>To solve the **Longest Substring Without Repeating Characters** problem, use a sliding window approach with two pointers: one to mark the start of the current substring and the other to expand it by iterating through each character in the string. Keep track of characters in a set or map, and when a duplicate character is found, move the start pointer rightward until the substring no longer contains duplicates. Track the maximum length of any substring encountered without duplicates to get the solution.<br><br>function longestSubstringWithoutRepeating(s):<br>    initialize maxLength = 0<br>    initialize start = 0<br>    create a map to store character indices (charIndexMap)<br><br>    for end from 0 to length of s - 1:<br>        if s[end] is in charIndexMap:<br>            // Move the start pointer to the right of the duplicate character's last occurrence<br>            start = max(start, charIndexMap[s[end]] + 1)<br>        <br>        // Update the character's latest index in the map<br>        charIndexMap[s[end]] = end<br><br>        // Update the maximum length<br>        maxLength = max(maxLength, end - start + 1)<br><br>    return maxLength<br>                                                                                                                                                                                                                                                          |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| longest repeating character replacement<br><br>Given a string `s` and an integer `k`, the goal is to find the length of the longest substring where you can change up to `k` characters to make all characters in the substring the same.                                                                                                                                                                                                                                                                                                                                                         | ### Approach to Solve the Problem<br><br>1. **Sliding Window with Frequency Count**:<br>    <br>    - Use a sliding window approach with two pointers: one (`start`) to mark the beginning of the window and another (`end`) to expand the window.<br>    - Track the frequency of each character within the window and keep track of the count of the most frequent character in the current window.<br>2. **Window Condition**:<br>    <br>    - For a window to be valid, the number of characters in the window minus the count of the most frequent character should be less than or equal to `k`.<br>    - If this condition isnâ€™t met, increment the `start` pointer to shrink the window.<br>3. **Result**:<br>    <br>    - Track the maximum length of a valid window.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Minimum Window Substring<br><br>Given two strings, `s` (the source string) and `t` (the target string), find the smallest substring in `s` that contains all characters in `t`. If there is no such substring, return an empty string. If there are multiple possible answers, return the first one found.                                                                                                                                                                                                                                                                                        | ### Approach to Solve the Problem<br><br>1. **Sliding Window with Frequency Count**:<br>    <br>    - Use two pointers (`start` and `end`) to create a sliding window in `s` and a frequency map to keep track of the counts of each character in `t`.<br>    - Expand the window by moving `end` and add characters to the windowâ€™s character count until the window contains all characters in `t` with the required frequencies.<br>2. **Shrink the Window**:<br>    <br>    - Once all characters are present in the window, move the `start` pointer to shrink the window and try to find a smaller valid substring.<br>    - Track the minimum window length and its position whenever a valid window is found.<br>3. **Result**:<br>    <br>    - If a valid window was found, return the substring. If no such window exists, return an empty string.<br><br>[[minimum window substring]]                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| \|\|Check for Anagrams\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          | To check if two strings are anagrams, first confirm they have the same length; if not, they canâ€™t be anagrams. Then, use a frequency counter (like a HashMap) to count occurrences of each character in the first string and decrease the count for each character in the second string. Finally, verify if all counts are zero; if they are, the strings are anagrams.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Group Anagrams<br><br>Given an array of strings `strs`, group the anagrams together.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              | - **Use a HashMap**:<br>    <br>    - Create a HashMap where the key is a representation of the characters in the string (typically sorted characters or a character count array), and the value is a list of strings (anagrams) that correspond to that key.<br>- **Character Sorting or Counting**:<br>    <br>    - For each string in the input array:<br>        - Sort the characters in the string and use the sorted string as a key in the HashMap.<br>        - Alternatively, count the occurrences of each character (using an array of size 26 for lowercase letters) to create a unique key.<br>- **Group Anagrams**:<br>    <br>    - For each string, add it to the list in the HashMap corresponding to its key.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  | Map<String, List<String>> anagramMap = new HashMap<>(); for (String str : strs) { // Sort the string to create a key char[] charArray = str.toCharArray(); Arrays.sort(charArray); String sortedKey = new String(charArray); // Add the original string to the list of anagrams anagramMap.putIfAbsent(sortedKey, new ArrayList<>()); anagramMap.get(sortedKey).add(str); }                                                                                                                                                               |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Check for balanced paranthesis](https://takeuforward.org/data-structure/check-for-balanced-parentheses/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | - **Initialize a Stack:** We'll use a stack to keep track of opening parentheses. Â <br>    <br>- **Iterate through the String:**<br>    - If the current character is an opening parenthesis, push it onto the stack. Â <br>        <br>    - If the current character is a closing parenthesis:<br>        - If the stack is empty, the string is unbalanced.<br>        - Pop the top element from the stack.<br>        - If the popped element doesn't match the current closing parenthesis, the string is unbalanced.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| \|Longest Palindromic Substring[Do it without DP]\|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Expand around centre <br>or <br>**Manacher's Algorithm**.<br><br>Helps to optmially find the next centre<br>WE should pick such a point as next center such that the palindrome around it expands till the right edge of characters we have explored till now                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Palindromic Substrings<br>returnÂ _the number ofÂ **palindromic substrings**Â in it_                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 | Similar approach as previous or DP                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Linked List                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Reverse a LinkedList](https://takeuforward.org/data-structure/reverse-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | To reverse a linked list, you need to iterate through the list while keeping track of three pointers: **previous**, **current**, and **next**. For each node, update its `next` pointer to point to the previous node, then move the pointers one step forward (i.e., `previous` becomes `current`, `current` becomes `next`). Continue this until all nodes have been reversed, and at the end, `previous` will be the new head of the reversed list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Detect a cycle in Linked List](https://takeuforward.org/data-structure/detect-a-cycle-in-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         | fast pointer and slow pointer collison                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| <br>\|[Merge two sorted Linked List (use method used in mergeSort)](https://takeuforward.org/data-structure/merge-two-sorted-linked-lists/)\|[](https://takeuforward.org/data-structure/merge-two-sorted-linked-lists/)\|\|[<br><br>](https://leetcode.com/problems/merge-two-sorted-lists/)\|\|                                                                                                                                                                                                                                                                                                  | To merge two sorted linked lists, initialize a dummy node to simplify the process, and use two pointers, one for each list, to compare nodes. Iteratively link the smaller of the two nodes to the merged list, advancing the pointer in that list, until one list is exhausted. Finally, link the remaining part of the non-empty list to the merged list, and return the merged list starting from the dummy node's next pointer.<br><br>4o                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| Merge K sorted arrays                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             | To merge kkk sorted arrays, use a **min-heap (priority queue)** to efficiently track the smallest current element from each array. Insert the first element of each array into the heap, and then repeatedly extract the smallest element from the heap, adding it to the merged list and pushing the next element from that array into the heap. Continue until all elements from every array have been added to the merged list, ensuring an optimal O(nlogâ¡k)O(n \log k)O(nlogk) time complexity, where nnn is the total number of elements.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Remove N-th node from back of LinkedList](https://takeuforward.org/data-structure/remove-n-th-node-from-the-end-of-a-linked-list/)                                                                                                                                                                                                                                                                                                                                                                                                                                                               | To remove the NNN-th node from the end of a linked list, use the **two-pointer technique** by starting two pointers, `fast` and `slow`, at the head. Move the `fast` pointer NNN nodes ahead, then move both pointers one step at a time until `fast` reaches the end, with `slow` pointing to the node before the target. Finally, adjust `slow.next` to skip the target node, effectively removing it from the list.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
| [Reorder List](https://takeuforward.org/data-structure/reorder-list/)<br>The **Reorder List** problem requires rearranging a singly linked list so that the nodes appear in a specific alternating order. Given a linked list L0â†’L1â†’L2â†’â‹¯â†’LnL_0 \rightarrow L_1 \rightarrow L_2 \rightarrow \dots \rightarrow L_nL0â€‹â†’L1â€‹â†’L2â€‹â†’â‹¯â†’Lnâ€‹, we want to reorder it to L0â†’Lnâ†’L1â†’Lnâˆ’1â†’L2â†’Lnâˆ’2â€¦L_0 \rightarrow L_n \rightarrow L_1 \rightarrow L_{n-1} \rightarrow L_2 \rightarrow L_{n-2} \dotsL0â€‹â†’Lnâ€‹â†’L1â€‹â†’Lnâˆ’1â€‹â†’L2â€‹â†’Lnâˆ’2â€‹â€¦. In other words, we rearrange the list to alternate nodes from the start and end. | To achieve this reordering efficiently, we can break down the solution into three main steps:<br><br>1. **Find the Middle of the List**:<br>    <br>    - Use the **fast and slow pointer technique** to find the middle node of the list. The `slow` pointer moves one step at a time, while the `fast` pointer moves two steps. By the time the `fast` pointer reaches the end, the `slow` pointer will be at the middle.<br>2. **Reverse the Second Half**:<br>    <br>    - Once we have the middle node, separate the list into two halves. Reverse the second half of the list starting from the node after the middle node. This reversal allows us to easily access nodes from the end in the new ordering.<br>3. **Merge the Two Halves**:<br>    <br>    - With two pointers (one starting at the head of the list and the other at the head of the reversed second half), alternately merge nodes from the two halves. This merges the nodes in the order required by the problem.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |                |                        |
